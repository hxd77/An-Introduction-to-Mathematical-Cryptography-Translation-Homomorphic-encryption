# BV11

1. 重新线性化技术，利用该技术获得一种无需依赖理想上的困难性假设的部分同态加密
2. 维度-模约简技术，该技术能将我们的某种同态加密方案转变为全同态加密方案，且无需人工压缩步骤和稀疏子集和假设



## 1.1再线性化：无需理想格的某种同态加密

Gentry构造的起点是一种 somewhat 全同态加密方案。对于一类电路 $\mathrm{C}$，一个 $\mathrm{C}$ 同态方案是指允许对 C 类中的任何电路进行求值的方案。Gentry工作中一个简单却惊人的发现是，如果一个 $\mathrm{C}$ 同态方案的（经过轻微增强的）解密电路属于 $\mathrm{C}$，那么该方案就可以被转换（或“引导”）为一个完全同态加密方案。

事实证明，能够执行相当数量的加法和乘法运算的加密方案已经很难获得了（即使不要求它们是可引导的）。Gentry对此的解决方案是基于环中理想的代数概念。

在很高的层面上，消息被视为一个环元素，密文是用一些“噪声”掩盖的消息。这个想法的新颖之处在于，噪声本身属于一个理想 $I $。因此，密文的形式为 $m + xI$（其中 $x$ 是环中的某个元素）。立刻可以注意到，该方案天生具有加法同态性；实际上，这也是我们在本文中所考虑的所有方案的情况。**理想 $I$ 有两个主要性质：第一，理想中的一个随机元素被假定能掩盖消息；第二，有可能生成一个秘密陷门来消除这个理想，即实现 $m + xI \rightarrow m$ 的转换。**

第一个性质保证了安全性，而第二个性质使得密文相乘成为可能。令 $c_1$ 和 $c_2$ 分别是 $m_1$ 和 $m_2$ 的加密结果。
$$
c_1c_2=(m_1+xI)(m_2+yI)=m_1m_2+(m_1y+m_2x+xyI)I=m_1m_2+zI
$$
解密时，理想被消除，而乘积 $m_1m_2$ 得以保留。因此，正如所要求的那样，$c_1c_2$ 确实是 $m_1m_2$ 的加密结果。这个巧妙的解决方案根据第一个特性，需要对特定环中的理想做出困难性假设。Gentry的原始研究依赖于对理想格的困难性假设，而范·戴克（van Dijk）、金特里（Gentry）、哈勒维（Halevi）和瓦伊昆坦纳森（Vaikuntanathan）[DGHV10]则提出了一种不同的实例化方法，该方法考虑了整数上的理想。

我们的某种同态方案基于带误差学习（LWE）问题的困难性，该问题最初由Regev提出。LWE假设指出，如果**$\mathbf{s}\in\mathbb{Z}_{q}^{n}$ 是一个 $ n$ 维秘密向量，那么任意多项式数量的、带有噪声的 $s$ 的系数的随机线性组合，在计算上与 $\mathbb{Z}_{q}$ 中的均匀随机元素是无法区分的。**从数学上讲，
$$
\begin{Bmatrix}\mathbf{a}_i,\langle\mathbf{a}_i,\mathbf{s}\rangle+e_i\end{Bmatrix}_{i=1}^{\mathrm{poly}(n)}\quad\overset{c}{\operatorname*{\approx}}\quad\begin{Bmatrix}\mathbf{a}_i,u_i\end{Bmatrix}_{i=1}^{\mathrm{poly}(n)},
$$
其中 $\mathbf{a}_i\in\mathbb{Z}_q^n$ 和 $\mathbf{u}_i\in\mathbb{Z}_q$ 是均匀随机的，噪声 $e_i$ 是从一种噪声分布中采样的，这种噪声分布输出的数值远小于 $q$（一个例子是$\mathbb{Z}_q$上具有小标准差的离散高斯分布）。

构建一种（密钥）加密方案，其安全性基于LWE假设，这是相当直接的。**要使用密钥$\mathbf{s}\in\mathbb{Z}_q^n$ 对一个比特 $m\in\{0,1\}$ 进行加密，我们选择一个随机向量 $\mathbf{a}\in\mathbb{Z}_q^n$ 和一个噪声 $e$，然后输出密文。**
$$
\begin{array}{ccc}c&=&(\mathbf{a},b=\langle\mathbf{a},\mathbf{s}\rangle+2e+m)\end{array}\quad\in\mathbb{Z}_q^n\times\mathbb{Z}_q
$$
**解密中的关键发现是，两个掩码——即秘密掩码 $\langle\mathbf{a},\mathbf{s}\rangle$ 和偶掩码 $2e$——不会相互干扰。也就是说，人们可以通过依次消除这两个掩码来解密密文：解密算法首先重新计算掩码 $\langle\mathbf{a},\mathbf{s}\rangle$  ，并从 $b$ 中减去它，得到 $2e+m({\mathrm{mod}}q).$ 。由于 $e\ll q$，那么 $2e+m({\mathrm{mod}}\ q)=2e+m$。现在，消除偶掩码变得很简单，只需计算$2e + m \mod 2$即可。**

为了更好地理解该方案的同态性质，让我们将注意力从加密算法转移到解密算法上。给定一个密文 $(\mathbf{a},b),$，考虑一个抽象线性函数  $f_{\mathbf{a},b}:\mathbb{Z}_{q}^{n}\to\mathbb{Z}_{q}$ ：
$$
f_{\mathbf{a},b}(\mathbf{x})=b-\langle\mathbf{a},\mathbf{x}\rangle({\mathrm{mod}}q)=b-\sum_{i=1}^n\mathbf{a}[i]\cdot\mathbf{x}[i]\quad\in\mathbb{Z}_q
$$
其中 $$ 表示变量，$(\mathbf{a},b),$表示线性方程组的公共参数。显然，密文 $(\mathbf{a},b)$ 的解密过程只不过是用密钥 $s$ 对这个函数进行求值（然后将结果对2取模）。

现在可以用这个函数 $f$ 来描述同态加法和乘法。将两个密文相加对应于两个线性函数的相加，其结果仍是另一个线性函数。具体来说，$f_{(\mathbf{a}+\mathbf{a}^{\prime},b+b^{\prime})}(\mathbf{x})=f_{\mathbf{a},b}(\mathbf{x})+f_{(\mathbf{a}^{\prime},b^{\prime})}(\mathbf{x})$ 是与同态相加的密文 $(\mathbf{a}+\mathbf{a}^{\prime},b+b^{\prime})$ 相对应的线性函数。同样地，将两个这样的密文相乘对应于这些线性方程的符号乘法。
$$
\begin{aligned}f_{(\mathbf{a},b)}(\mathbf{x})\cdot f_{(\mathbf{a}^{\prime},b)}(\mathbf{x})&=\quad(b-\sum\mathbf{a}[i]\mathbf{x}[i])\cdot(b^{\prime}-\sum\mathbf{a}^{\prime}[i]\mathbf{x}[i])\\&=\quad h_0+\sum h_i\cdot\mathbf{x}[i]+\sum h_{i,j}\cdot\mathbf{x}[i]\mathbf{x}[j],\end{aligned}
$$
这就产生了一个关于变量$\mathbf{x}=(\mathbf{x}[1],\ldots,\mathbf{x}[n])$的二次多项式，其系数$h_{i,j}$可以通过展开上述表达式的括号，由$(\mathbf{a},b),$ 和 $(\mathbf{a}^{\prime},b)$ 计算得出。和之前一样，解密过程包括用密钥 $s$ 对这个二次表达式进行求值（然后对2取模）。我们现在遇到了一个严重的问题：解密算法必须知道这个二次多项式的所有系数，这意味着密文的大小从 $n+1$ 个元素增加到了（大约）$n^2/2$个元素。

这就是我们的重新线性化技术发挥作用的地方。重新线性化是一种将密文大小缩减回 $n + 1$ 的方法。其主要思路如下：假设我们在新的密钥 $t$ 下发布了密钥 $s$ 中所有线性项和二次项的加密结果，即所有的数值 $s[i]$以及$s[i]s[j]$。因此，这些（二次项的）密文看起来就像 $(\mathbf{a}_{i,j},b_{i,j})$，其中
$$
b_{i,j}=\langle\mathbf{a}_{i,j},\mathbf{t}\rangle+2e_{i,j}+\mathbf{s}[i]\cdot\mathbf{s}[j]\approx\langle\mathbf{a}_{i,j},\mathbf{t}\rangle+\mathbf{s}[i]\cdot\mathbf{s}[j]
$$
现在，总和 **$h_0+\sum h_i\cdot\mathbf{s}[i]+\sum h_{i,j}\cdot\mathbf{s}[i]\mathbf{s}[j]$** 可以（近似地）写成
$$
\begin{aligned}h_0+\sum h_i(b_i-\langle\mathbf{a}_i,\mathbf{t}\rangle)+\sum_{i,j}h_{i,j}\cdot(b_{i,j}-\langle\mathbf{a}_{i,j},\mathbf{t}\rangle),\end{aligned}
$$
你瞧，这是一个关于 $t$ 的线性函数！关键在于，将两个线性函数$f_({\mathbf{a},b)}$和$f_{(\mathbf{a}^{\prime},b^{\prime})}$相乘，然后对所得表达式进行重新线性化，会得到一个具有 $n+1$ 个系数的线性函数，用新的密钥 $t$ 对该函数求值（再对2取模），结果就是两个原始消息的乘积。生成的密文就是这个线性函数的系数，其数量最多为 $n+1$。使用密钥 $t$ 对该密文解密，会得到 $m\cdot m^{\prime}$。

在这个半正式的描述中，我们忽略了一个重要细节，这个细节与系数 $h_{i,j}$ 可能很大这一事实有关。因此，即使（bij − aij t）∈ s[i]s[j]，也可能出现hij（bij − aij t）的情况。hij的表示，即hij = （aij − bij），使得
