

## CKKS explained series  CKKS 讲解系列

[Part 1, Vanilla Encoding and Decoding  
第一部分，原始编码和解码](https://blog.openmined.org/ckks-explained-part-1-simple-encoding-and-decoding/)  
[Part 2, Full Encoding and Decoding  
第 2 部分，完整编码和解码](https://blog.openmined.org/ckks-explained-part-2-ckks-encoding-and-decoding/)  
Part 3, Encryption and Decryption  
第 3 部分，加密和解密  
[Part 4, Multiplication and Relinearization  
第 4 部分，乘法和重线性化](https://blog.openmined.org/ckks-explained-part-4-multiplication-and-relinearization/)  
[Part 5, Rescaling  第 5 部分，重新缩放](https://blog.openmined.org/ckks-explained-part-5-rescaling/)

## Introduction  介绍

在上一篇文章[《CKKS 详解，第二部分：完整的编码与解码》](https://blog.openmined.org/ckks-explained-part-2-ckks-encoding-and-decoding/)中，我们了解了如何实现 CKKS 的编码器和解码器，它们能够将向量转换为多项式，反之亦然。我们将会发现，这一步骤是必要的，因为在构建同态加密方案时，使用多项式比直接使用向量要高效得多。

在本文中，我们将了解如何利用诸如**LWE**或**RLWE**之类的困难问题来构建近似同态加密方案。CKKS使用近似算术而非精确算术，也就是说，当我们完成计算后，得到的结果可能与直接进行计算得到的结果略有不同。这意味着，如果你加密2和3，对它们的密文进行加法运算，然后解密，得到的结果可能是 $4.99$ 或 $5.01$ 之类的数值，而不是 $5$。像BFV这样的其他方案则是精确的，这意味着它们会得出确切的 $5$。

那么为什么要使用CKKS呢？CKKS更适合实数运算，在这种运算中我们可以得到近似但接近的结果，而BFV则更适合整数运算。

在本文中，我们将了解如何使用LWE和RLWE来实现一种近似算术同态加密方案的加密与解密过程。

## Learning with Error  错误学习

CKKS是一种公钥加密方案，其中会生成一个私钥和一个公钥。公钥用于加密且可以共享，而私钥用于解密且必须保密。

CKKS以及许多其他同态加密方案的基础是**带误差学习**（LWE）问题，该问题最初由雷格夫在论文[《On lattices, learning with errors, random linear codes, and cryptography》](https://cims.nyu.edu/~regev/papers/qcrypto.pdf)中提出。LWE问题是要在$\mathbb{Z}_q^n\times\mathbb{Z}_q$中区分形如$(a_i,b_i)=(a_i,\langle a_i,s\rangle+e_i)$的含 噪声对与真正随机的对。这里，$a_i,s\in\mathbb{Z}_q^n$是均匀采样的，$s$ 是我们的秘密，而$e_i\in\mathbb{Z}_q$是小噪声（通常为高斯噪声），用于增加问题的难度。如果我们不引入 $e_i$，这个问题解决起来会容易得多，因为我们可以使用高斯消元法来求解这个线性方程组。

已知LWE问题与最坏情况下的格问题一样难解，而这些格问题目前能够抵御来自量子计算机的攻击。**因此，我们可以利用从$(a_i,\langle a_i,s\rangle+e_i)$对中求解秘密 $s$ 十分困难这一特性，基于此构建密码系统。**

假设我们生成了一个秘密密钥$s\in\mathbb{Z}_q^n$，我们将其保密，并发布 $n$ 对类型为$(a_i,\langle a_i,s\rangle+e_i)$的数据，这些数据可以用矩阵形式表示为$(A,A\cdot s+e)$，其中$A\in\mathbb{Z}_q^{n\times n},e\in\mathbb{Z}_q^n$。正如LWE问题所阐述的，**从这对数据中恢复秘密密钥是很困难的，因此我们可以利用这一点来创建一个公钥。**

事实上，我们将使用$p=(-A\cdot s+e,A)$作为我们的公钥，它可以公开使用，因为很难从中提取出私钥。我们选择存储$-A\cdot s$而非$A\cdot s$是为了方便，这一点我们稍后会看到，但这并不会改变问题本身。

那么，要使用公钥和私钥对消息$\mu\in\mathbb{Z}_q^n$进行加密和解密，我们可以采用以下方案：

- 使用 $p$ 对 $μ$ 进行加密：输出 $c=(\mu,0)+p=(\mu-A\cdot s +e,A)=(c_0,c_1)$
- 使用 $s$ 对 $c$ 进行解密：输出 $\tilde{\mu}=c_0+c_1\cdot s=\mu–A\cdot s+e+A\cdot s=\mu+e\approx\mu$

因此，在加密阶段，我们获取公钥，并使用它对我们的消息 $μ$ 进行掩盖。这样，消息就被隐藏在密文的第一个坐标中，同时带有掩码 $−A⋅s$。请记住， $A$ 是随机均匀采样的，所以它确实能有效地掩盖 $μ$。为了解除掩盖，我们可以使用 $c$ 的第二个坐标（该坐标只存储 $A$），并将其与私钥 $s$ 结合，从而得到解密结果 $μ+e$。请注意，这里我们得到的并非原始消息 $μ$，而是 $μ$ 加上一些噪声 $e$ ，这就是为什么我们说这是一种近似算术方案。如果 $e$ 足够小，那么解密结果就会接近原始的μ。

因此，我们在这里已经了解了如何利用LWE问题构建一个能够抵御量子攻击的公钥加密方案。上述实现存在一个问题：虽然私钥的大小为 $O(n)$，但由于矩阵 $A$ 的存在，公钥的大小达到了 $O(n²)$，并且计算过程也需要O(n²)次运算。由于n会决定我们方案的安全性，若使用LWE来构建该方案，在实际应用中会效率过低，因为O(n²)的密钥大小和计算复杂度会使其过于不切实际。

## Ring Learning with Error

这就是为什么我们要研究《关于理想格与环上的带误差学习》中提出的环上带误差学习问题，它是带误差学习（LWE）的一种变体，但适用于环。我们不再处理 $\mathbb{Z}_q^n$ 中的向量，而是研究$\mathbb{Z}_q[X]/(X^N+1)$中的多项式（这里我们假设 $N$ 是 $2$ 的幂）。因此，现在我们从$\mathbb{Z}_q[X]/(X^N+1)$中选取 $a$ 、 $s$ 和 $e$ ，其中 $a $ 仍然是均匀采样的，$s$ 是一个小的秘密多项式，$e$ 是一个小的噪声多项式。转向环上带误差学习（RLWE）有两个主要优势：

- 密钥大小不再是二次的，而是线性的，因为我们现在输出的公钥为 $p=(-a·s + e, a)$，其中 $a·s$ 表示 $a$ 与 $s$ 的多项式乘积。由于所有运算都在多项式之间进行，私钥和公钥的大小均为 $O(n)$。
- 多项式需要进行乘法运算，因此可以使用离散傅里叶变换来进行多项式乘法，其时间复杂度为 $O(nlog(n))$，而不是因为必须进行矩阵向量乘法而产生的 $O(n²)$。

因此，通过使用RLWE而非LWE，我们将拥有小得多的密钥，运算速度也会更快，因此上述方案会变得更加实用。此外，RLWE仍然是一个难题，能提供强大的安全保障，因此使用RLWE仍能得到一个安全的方案。

我们现在明白为什么研究多项式很重要了，因为它们为一种高效且安全的方案提供了基础。因此，你现在应该能理解我们为什么要不厌其烦地将向量转换为$\mathbb{Z}_q[X]/(X^N+1)$中的多项式，以及进行反向转换了，**因为我们现在可以利用多项式环的代数结构**。

## Homomorphic operations

现在我们已经了解了为什么要研究$\mathbb{Z}_q[X]/(X^N+1)$上的多项式，以及如何基于此得到一种加密方案，接下来让我们看看如何定义密文的加法和乘法，以获得一种同态加密方案。

所以我们说，我们有一个秘密 $s$ ，还有一个公钥 $p=(b,a)=(-a·s + e,a)$。要加密一条消息 $μ$，我们只需输出 $c=(μ + b,a)$，而要用 $s$ 解密的话，我们对 $c_0 + c_1·s=(\mu+b+a\cdot s=\mu-a\cdot s+e+a\cdot s=\mu +e)$进行运算，其结果会近似等于原始消息。

### Addition

现在假设我们有两条消息 $μ$ 和 $μ'$，我们将它们加密为 $c=(c_0,c_1)$ 和 $c'=(c_0',c_1')$。那么 $c_{add} = c + c' = (c_0 + c_0',c_1 + c_1')$就是 $μ + μ'$的正确加密结果，也就是说，当我们用 $s$ 对其解密时，会得到（近似的）$μ + μ'$。

的确，$c_{add}$的解密机制产生
$$
\begin{aligned}&c_{add,0}+c_{add,1}\cdot s=c_0+c_0^{\prime}+(c_1+c_1^{\prime})\cdot s=c_0+c_1\cdot       s+c_0^{\prime}+c_1^{\prime}\cdot s=\\&\mu+\mu^{\prime}+2e\approx\mu+\mu^{\prime}\end{aligned}
$$


，因为我们说过 $e$ 是可忽略不计的。

这意味着，如果你将密文相加，然后对它们进行解密，你会得到明文的和！这表明，通过这种简单的方案，你可以让某人对加密数据执行加法操作，而用户仍然可以解密并得到正确的结果。这是我们朝着同态加密方案迈出的第一步。

### Multiplication

尽管如此，我们仍然需要定义密文的乘法运算，这涉及到更多内容。实际上，我们的目标是找到一个密文 $c_{mult}$，使得当我们用密钥 $s$ 对其解密时，能得到明文的乘积。

**由于将两个密文相乘更为复杂，我们现在将首先重点关注如何将一个密文与一个明文相乘，并在后续文章中介绍密文之间的乘法运算方法。**

假设我们有一个明文 $μ$ ，它被加密成密文 $c=(c_0,c_1)$，还有一个明文 $μ^\prime$。那么，要得到乘法运算的密文，我们只需要输出$c_{mult}=(\mu^{\prime}\cdot c_0,\mu^{\prime}\cdot c_1)$。

的确，在对 $c_{mult}$ 进行解密时，我们得到$\mu^{\prime}\cdot c_0+\mu^{\prime}\cdot c_1\cdot s=\mu^{\prime}\cdot(c_0+c_1\cdot s)=\mu^{\prime}\cdot(\mu+e)=\mu^{\prime}\cdot\mu+\mu^{\prime}\cdot e\approx\mu^{\prime}\cdot\mu.$。

因此，通过这些加法和乘法的实现方式，我们已经看到，对某些数据进行加密、对加密后的数据执行运算，然后再解密，得到的结果与直接对明文数据进行计算得到的结果是相同的，这是完全可行的。

因为我们还有一些概念需要讲解，比如密文-密文乘法、重线性化和重缩放，所以暂时不会涉及代码实现。等我们掌握了所有的构建模块后，就会把它们整合起来，形成一个端到端的近似同态加密方案，类似于CKKS！

所以我希望你已经理解了如何使用环学习错误（RLWE）构建同态加密方案，接下来，我们将学习密文到密文的乘法！