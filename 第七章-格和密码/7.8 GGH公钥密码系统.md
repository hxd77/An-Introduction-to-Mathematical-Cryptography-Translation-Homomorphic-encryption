## 7.8 GGH公钥密码系统



Alice 首先选择一组线性无关的向量：
$$
v_1,v_2,\dots,v_n \in \mathbb{Z}^n\\
$$
彼此较为正交(reasonably orthogonal to one another)。为做到这一点，可以固定一个参数 $d$ 并从 $-d$ 到 $d$ 之间随机选择 $v_1,\dots,v_n$ 的坐标。Alice 可以检查 Hadamard 比率来检查所选择的基是好的。这组向量便是 Alice 的私钥。为了叙述方便，我们令 $V$ 表示行向量为 $v_1,\dots,v_n$ 的 $n\times n$ 矩阵，$L$ 是由这组向量生成的格。

Alice 随后选择一个 $n\times n$ 的整系数矩阵 $U$，满足行列式 $\det(U)=\pm 1$。创建 $U$​ 的一种方法是将大量随机选择的初等矩阵(elementary matrix)相乘。

> 初等矩阵的行列式只有三种情况：  
> 1\. 两行(列)互换：$\det(P)=-1$；  
> 2\. 某行乘以一非零常数 $k$：$\det(D)=k$；  
> 3\. 第 $i$ 行加上第 $j$ 行的 $m$ 倍：$\det(T)=1$​；  
> 设 $E_1,\dots,E_n$ 是随机选择的初等矩阵，  
> $\det(U)=\det(E_1\cdots E_n)=\det(E_1)\cdots\det(E_n)=1\\$则在选择时需要注意上面的3条性质，使得最后的行列式为1即可。

Alice 计算：

$W=UV.\\$

那么矩阵 $W$ 的行向量 $w_1,\dots,w_n$ 就是 $L$ 的一个新的基。令其作为 Alice 的公钥。

当 Bob 想要发送给 Alice 一个消息，他选择一个小向量 $m$ 作为明文，例如 $m$ 可以是一个二进制向量(binary vector)。Bob 同时也选择一个小的随机扰动向量 $r$ 作为临时密钥(ephemeral key)。例如，Bob 可能在区间 $[-\delta, \delta]$ 随机选择 $r$ 的坐标，$\delta$ 是一个固定的公共参数。他随后计算向量：

$e=mW+r=\sum_{i=1}^n m_iw_i+r,\\$

作为密文。注意到，$e$ 不是一个格点，但是其非常接近格点 $mW$，因为 $r$ 非常小。

解密过程很直接。Alice 根据 Babai 的算法，利用好的基底 $v_1,\dots,v_n$ 来寻找格 $L$ 中最接近 $e$ 的向量。由于她使用的是好的基且 $r$ 很小，所以她找到的格向量就是 $mW$。随后，她再右乘一个 $W^{-1}$ 来恢复 $m$。下图总结了 GGH 密码系统。

![image-20251005190428488](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251005190428566.png)

图 1. GGH 密码系统，源自《An Introduction to Mathematical Cryptography》




_Example._ 我们以 3 维为例来解释 GGH 密码系统的原理。对于 Alice 的私有的好基我们令：

$$
v_1=(-97,19,19),\ v_2 = (-26,30,86),\ v_3=(-184,-64,78).\\
$$


由 $v_1,v_2,v_3$ 扩张成的格 $L$ 的行列式为 $\det(L)=859516$，Hadamard 比率为：

$$
\mathcal{H}(v_1,v_2,v_3)=\left(\frac{\det(L)}{\left\lVert v_1\right\rVert \left\lVert v_2\right\rVert\left\lVert v_3\right\rVert} \right)^{1/3}\approx 0.74620.\\
$$


Alice 用矩阵 $U$ 乘以私有的基底：

$$
U=\left(\begin{array}44327 & -15447 & 23454\\3297 &-11770 & 17871\\5464 & -19506 & 29617\end{array}\right),\\
$$


其行列式 $\det(U)=-1$，创建得到公共基底：

$$
\begin{align}w_1&=(−4179163,−1882253,583183),\\w_2&=(−3184353,−1434201,444361),\\w_3&=(−5277320,−2376852,736426).\end{align}\\
$$


这组公共基底的 Hadamard 比率就非常小了：

$$
\mathcal{H}(w_1,w_2,w_3)=\left(\frac{\det(L)}{\left\lVert w_1\right\rVert \left\lVert w_2\right\rVert\left\lVert w_3\right\rVert} \right)^{1/3}\approx 0.0000208.\\
$$


Bob 决定发送 $m = (86,−35,−32)$ 给 Alice，并添加一个随机扰动 $r =(−4,−3,2)$。相应的密文为：

$$
\begin{align}e&=(86,−35,−32)\left(\begin{array}−4179163&−1882253& 583183\\−3184353&−1434201&444361\\−5277320&−2376852&736426\end{array}\right)+(−4,−3,2)\\&=(−79081427,−35617462,11035473).\end{align}\\
$$


Alice 用 Babai 的算法进行解密。她首先将 $e$ 写成私有基底的实系数线性组合的形式：

$$
e\approx 81878.97v_1 −292300.00v_2 +443815.04v_3.\\
$$


她将系数四舍五入到最近的整数并计算得到格向量：

$v=81879v_1 −292300v_2 +443815v_3 =(−79081423,−35617459,11035471)\\$

非常接近于 $e$。随后她恢复 $m$ 通过将 $v$​ 表示为公共基的线性组合的形式，并从中提取出系数，

$v =86w_1−35w_2−32w_3.\\$

现在假设 Eve 尝试解密 Bob 的消息，但是她只知道公共的基底 $w_1,w_2,w_3$。如果用公共基来运行 Babai 的算法，她会得到：

$e \approx 75.76w_1-34.52w_2-24.18w_3.\\$

四舍五入，她便会得到一个格向量：

$v^{'}=75w_1-35w_2-24w_3=(−79508353,−35809745,11095049)\\$

也比较接近 $e$。然而，这个格向量却给出了错误的明文 $(76,−35,−24)$，而不是 $m = (86,−35,−32)$。对比 Babai 算法在不同基底下的表现是很有启发性的。我们发现：

$\left\lVert e-v\right\rVert \approx 5.3852 \quad \text{and} \quad \left\lVert e-v^{'}\right\rVert \approx472000.\\$

当然了，GGH 密码系统在 3 维上本身就不安全，因为即使我们使用足够大的数字来使穷举搜索变得不切实际，在低维空间中仍然有高效的算法来寻找好的基。在二维空间中，一个寻找好基的算法最早可以追溯到 Gauss。一个强大的推广到任意维度的算法，被称为 [LLL 算法](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=LLL+%E7%AE%97%E6%B3%95&zhida_source=entity)，将在后面介绍。

_Remark._ 我们观察到，GGH 是一个概率加密系统的例子，因为由于随机扰动 r 的选择，单个明文会导致许多不同的密文。如果 Bob 两次使用不同的随机扰动发送相同的消息，或者使用相同的随机扰动发送不同的消息，这都可能会导致潜在的危险。因此，在实践中，随机扰动 $r$ 是通过将 hash 函数应用于明文 $m$ 来确定的。

_Remark._ GGH 的一个替代版本颠倒了 $m$ 和 $r$ 的角色，因此密文具有 $e = rW + m$ 的形式。Alice 通过计算最接近 $e$ 的格向量来找到 $rW$，然后她将明文恢复为 $m = e - rW$。