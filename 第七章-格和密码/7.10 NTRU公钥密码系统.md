## 7.10 NTRU公钥密码系统

基于整数分解问题或者离散对数问题的密码系统都是定义在群上的，因为他们底层的困难问题只涉及一种运算。对于 RSA，Diffie-Hellman 和 ElGamal，群是模 $m$ 的单位群，其中模数 $m$ 可能是素数或合数，群运算是模 $m$ 的乘法。对于 ECC，群是模 $p$ 的椭圆曲线上的点集，群运算是椭圆曲线加法。

环是具有两种运算(加法和乘法)的代数结构，这两种运算通过分配律(distributive law)相关联。在本节中，我们描述 NTRU 公钥密码系统。NTRU 自然地使用了卷积多项式环来描述，但其底层的数学困难问题也可以被解释为格中的 SVP 或 CVP。我们将在后面一节讨论其与格的联系。

> NTRU(N-th degree truncated polynomial ring units) 最初提出时并不是明确基于格理论的，而是一种基于多项式环的公钥密码系统。后来发现 NTRU 密码系统的安全性可以与格上的 SVP 联系起来。这使得 NTRU 成为了基于格的密码系统的一部分。

### 7.10.1 NTRU加密

这一节我们讨论 NTRU(读作 $en-tr\bar{u}$) 公钥密码系统。对于整数 $N>1$ 和两个模数 $p,q$，我们令 $R,R_p,R_q$ 表示卷积多项式环：

$$
R=\mathbb{Z}[x]/(x^N-1),\quad R_p=\mathbb{Z}_p[x]/(x^N-1),\quad R_q=\mathbb{Z}_q[x]/(x^N-1)\\
$$


我们可以将多项式 **$a(x)\in R$ 视为 $R_p$ 或 $R_q$ 中的元素**，方法是将其系数模 $p$ 或 $q$ 约减。反过来，我们可以使用中心提升(centered lift)将元素从 $R_p$ 或 $R_q$ 移动到 $R$。我们对参数 $N$、$p$ 和 $q$ 做了很多假设，**特别是要求 $N$ 为素数，且 $\gcd(N,q) = \gcd(p,q) = 1$**。

> 这些假设的原因在课后练习 7.30 和 7.33 中有解释。简单来说：  
> **1\. 如果 $\gcd(p,q) \neq1$ 即 $p|q$，则 Eve 能够在不知道私钥的情况下恢复出消息；  
> 2\. 如果 $N$ 不为素数，则 Eve 能够更容易地恢复出私钥**

在描述 NTRU 密码系统之前,我们还需要一个符号。



**Definition.** 对于任意的正整数 $d_1,d_2$，我们令：
$$
\mathcal{T}(d_1,d_2)=\left\{\begin{align}&a(x)\text{ has }d_1\ \text{coefficients equal to }1,\\a(x)\in R:\ & a(x)\text{ has }d_2\ \text{coefficients equal to }-1,\\& a(x)\text{ has all other coefficients equal to }0\\\end{align}\right\}.\\
$$

**多项式 $\mathcal{T}(d_1,d_2)$ 被称为三元多项式(ternary/trinary polynomials)**。它们和二元多项式(binary polynomials)类似，后者的系数只能取 0 或 1。

下面正式开始介绍 NTRU 密码系统。Alice 或一些可信权威(trusted authority)选择**公共参数 $(N,p,q,d)$，**满足 $N,p$ 都是素数，$\gcd(p,q)=\gcd(N,q)=1$，且 $q>(6d+1)p$。Alice 的私钥包含两个随机选择的多项式

$$
f(x)\in \mathcal{T}(d+1,d)\quad\text{and}\quad g(x)\in \mathcal{T}(d,d).\\
$$


随后，Alice 计算逆：

$$
F_q(x)=f(x)^{-1} \in R_q\quad\text{and}\quad F_p(x)=f(x)^{-1}\in R_p.\\
$$

如果多项式的逆不存在的话，Alice 只需丢弃当前的 $f(x)$ 并重新选择一个新的即可。**Alice 在 $\mathcal{T}(d+1,d)$ 上选择 $f(x)$ 而不是 $\mathcal{T}(d,d)$，因为 $\mathcal{T}(d,d)$ 上的元素在 $R_q$ 上不存在逆元。**

>设 $n=8, q=17$：
>
>* $x^8+1$ 在 $\mathbb{Z}_{17}$ 中。
>  
>* 取 $f(x)=x^2-x-1+x^4+x^7-x^6-x^3$，其中正负项相等（$\mathcal{T}(3,3)$）。
>  
>* 那么 $f(1)=0$，说明有因子$x-1$  
>    ⇒ 与 $x^8-1$ 有公共因子$x-1$，  
>    ⇒ 在 $R_{17}$ 中无逆。
>    
>* 若改成 $f(x)=x^2-x-1+x^4+x^7-x^6-x^3+1$，  
>    则 $f(1)=1$，  
>    ⇒ 通常可逆。

Alice 接着计算：

$$
h(x)=F_q(x)\star g(x) \in R_q.\\
$$

**多项式 $h(x)$ 作为 Alice 的公钥，私钥为 $(f(x),F_p(x))$**。此外，Alice 可以只存储 $f(x)$，在需要的时候再重新计算 $F_p(x)$。

**Bob 的明文是多项式 $m(x)\in R$，系数取自 $-\frac 1 2p$ 到 $\frac{1}{2}p$。**即，明文 $m$ 是 $R_p$ 中的一个多项式经过中心提升后得到的 $R$ 上的多项式。**Bob 选择一个随机多项式(临时密钥) $r(x)\in \mathcal{T}(d,d)$** 并计算：
$$
e(x)\equiv ph(x)\star r(x)+m(x)\pmod q.\\
$$


密文 $e(x) \in R_q$.

Alice 在收到 Bob 的密文之后，运行解密算法通过计算：

$$
a(x)\equiv f(x)\star e(x)\pmod{q}.\\
$$


之后，将 $a(x)$ 中心提升到 $R$ 中的一个元素，并模 $p$.

$$
b(x)\equiv F_p(x)\star a(x)\pmod{p}.\\
$$


若参数选择合理，我们现在验证多项式 $b(x)$ 就等于 $m(x)$。NTRU 公钥密码系统也被称为 $\text{NTRUE}_\text{NCRYPT}$，总结于下图：

![image-20250922215515658](https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/image-20250922215515658.png)

图 1. NTRU 公钥密码系统，源自《An Introduction to Mathematical Cryptography》



**Proposition 7.48** 如果 NTRU 所选参数 $(N,p,q,d)$ 满足：
$$
q>(6d+1)p,\\
$$

**则 Alice 计算得到的多项式 $b(x)$ 就是 Bob 的明文 $m(x)$。**

_Proof._ 我们首先要更精确地确定 Alice 计算 $a(x)$ 时的形式。

$$
\begin{align}a(x)&\equiv f(x)\star e(x)\pmod{q}\\&\equiv f(x)\star(ph(x)\star r(x)+m(x))\pmod{q}\quad &\text{展开} e(x)\\&\equiv pf(x)\star F_q(x)\star g(x)\star r(x)+f(x)\star m(x)\pmod{q}\quad &\text{展开} h(x)\\&\equiv p  g(x)\star r(x)+f(x)\star m(x) \pmod{q} \quad &F_q(x) = f(x)^{-1}\\\end{align}\\
$$


考虑多项式

$$
p  g(x)\star r(x)+f(x)\star m(x),\tag{*}\\
$$


只在 $R$ 上计算而不模 $q$。我们需要界定最大可能系数。$g(x),r(x)\in \mathcal{T}(d,d)$，若在卷积 $g(x)\star r(x)$ 中，所有的 1 相匹配，所有的 -1 相匹配，此时最大的系数值为 $2d$。类似地，$f(x) \in \mathcal{T}(d+1,d)$，$m(x)$ 的系数在 $-\frac{1}{2}p$ 到 $\frac{1}{2}p$ 之间，因此 $f(x)\star m(x)$ 的最大的系数值为 $(2d+1)\cdot \frac{1}{2}p$。因此,即使 $g(x) \star r(x)$ 的最大系数恰好与 $f(x) \star m(x)$ (这一项在教材里写的是 $r(x) \star m(x)$，个人认为是作者笔误)的最大系数重合，$(*)$ 式的**最大系数的绝对值最多为：**

$$
p\cdot 2d+(2d+1)\cdot\frac{1}{2}p = \left(3d+\frac{1}2\right)p.\\
$$


因此我们的假设 $q>(6d+1)p$ 保证了 $(*)$ 式的每个系数都严格小于 $\frac{1}2 q$。因此，当 Alice 在 $R_q$ 中计算 $a(x) \pmod{q}$ 时，就会提升到 $R$ 中，她便能恢复出 $(*)$ 式的准确值。换句话说，

$$
a(x)=p  g(x)\star r(x)+f(x)\star m(x),\\
$$


在 $R$ 中是成立的，就不需要再模 $q$ 了。

剩下的就简单了。Alice 用 $F_p(x)$ 乘 $a(x)$，将结果模 $p$ 得到：

$$
\begin{align}b(x)&=F_p(x)\star a(x) \pmod p\\&=F_p(x)\star (p  g(x)\star r(x)+f(x)\star m(x))\pmod p\\&\equiv F_p(x)\star f(x)\star m(x)\pmod p\\&\equiv m(x)\pmod p.\end{align}\\
$$
因此，$b(x)$和$$m(x)$$模$p$同余。



_Remark 7.49._ $q>(6d+1)p$ 的条件保证了解密不会失败。但是，在证明过程中我们也看到，即使对于小一点的 $q$，解密也是有可能成功的。因为 $g(x)$ 和 $r(x)$ 的正系数和负系数完全排列一致的可能性非常小，$f(x)$ 和 $m(x)$ 也是如此。所以，出于效率和降低公钥大小的考虑，选择一个小一点的 $q$ 或许更有优势。在这种情况下，估计解密失败的概率就是一个精细的问题了。解密失败的概率必须非常小(例如,小于 $2^{-80}$)，因为解密失败有可能向攻击者泄露私钥信息。

_Remark. 7.50_ 注意到 NTRU 是一个概率密码系统的例子，因为同一个明文 $m(x)$ 会因为临时密钥 $r(x)$ 的不同选择而得到不同的加密结果。于是，无论是用不同的临时密钥加密两个相同的消息，还是用相同的临时密钥加密两个不同的明文，对于 Bob 来说都不是好的做法。标准的做法是用明文的 hash 值来生成临时密钥。

_Remark 7.51._ 如果多项式 $f(x)\in\mathcal{T}(d+1,d)$ 的系数较小，那么它的逆 $F_q(x)\in R_q$ 的系数在模 $q$ 的意义下往往是均匀随机的分布。这并不是一个定理，但却是实验观察到的结果。例如，我们令 $N=11，q=73$，选择一个随机的多项式：

$$
f(x)=x^10 +x^8 −x^3 +x^2 −1 \in\mathcal{T}(3,2).\\
$$


则 $f(x)$ 在 $R_q$ 上是可逆的，它的逆

$$
F_q(x)=22x^{10}+33x^9+15x^8+33x^7−10x^6+36x^5−33x^4−30x^3+12x^2−32x+28\\
$$


的系数看起来是随机的。类似地，公钥和密文的系数：

$$
h(x)\equiv F_q(x)\star g(x)\pmod{q}\quad\text{and}\quad e(x)\equiv pr(x)\star h(x)+m(x)\pmod{q},\\
$$
在模 $q$ 的意义下看起来也是随机分布的。



_Remark 7.52._ 使用基于格的密码系统的一个动机是它们的执行速度比基于离散对数和因子分解的密码系统更快。那么 NTRU 有多快呢?在加密和解密过程中最耗时的部分是卷积操作。通常情况下，计算卷积 $a\star b$ 需要 $N^2$ 次乘法运算，因为每个系数实质上是两个向量的点积。但是 NTRU 中所需的卷积形式为 $r\star h$，$f\star e$ 和 $F_p\star a$，其中 $r$、$f$ 和 $F_p$ 是三元多项式。因此这些卷积可以不需要任何乘法运算就能计算出来，只需要大约 $\frac{2}{3}N^2$ 次加法和减法运算。如果 $d$ 小于 $N/3$，前两个卷积只需要 $\frac{2}3dN$ 次加法和减法。因此 NTRU 的加密和解密过程需要 $O(N^2)$ 步，而每步都是非常快速的。



_Example 7.53._ 我们给出 NTRU 的一个小例子，公共参数设置为：

$$
(N,p,q,d)=(7,3,41,2).\\
$$
我们有：

$$
41 = q>(6d+1)p =39,\\
$$


因此解密将会成功。Alice 选择：

$$
f(x)=x^6−x^4+x^3+x^2−1 \in\mathcal{T}(3,2)\quad \text{and}\quad g(x)=x^6+x^4−x^2−x \in\mathcal{T}(2,2).\\
$$


并计算逆：

$$
\begin{align}F_q(x)&=f(x)^{−1} \pmod{q} =8x^6 +26x^5 +31x^4 +21x^3 +40x^2 +2x+37\in R_q,\\F_p(x)&=f(x)^{−1} \pmod{p} = x^6 +2x^5 +x^3 +x^2 +x+1\in R_p.\end{align}\\
$$


她存储 $(f(x),F_p(x))$ 作为私钥，计算并发布公钥：

$$
h(x)=F_q(x)\star g(x)=20x^6 +40x^5 +2x^4 +38x^3 +8x^2 +26x+30\in R_q.\\
$$


Bob 决定发送给 Alice 消息：

$$
m(x)=−x^5 +x^3+x^2−x+1\\
$$
临时密钥为：

$$
r(x)=x^6 −x^5 +x−1.\\
$$


Bob 计算并发送给 Alice 密文：

$$
e(x) \equiv pr(x)\star h(x)+m(x)\equiv 31x^6+19x^5+4x^4+2x^3+40x^2+3x+25 \pmod{q}.\\
$$


解密过程就很简单了。首先她计算：

$$
f(x)\star e(x) \equiv x^6 +10x^5 +33x^4 +40x^3 +40x^2 +x+40 \pmod{q}.\\
$$


随后获得：

$$
a(x)=x^6 +10x^5 −8x^4 −x^3 −x^2 +x−1\in R\\
$$


最后，对 $a(x)$ 模 $p$ 并计算：

$$
F_p(x)\star a(x) \equiv 2x^5 +x^3 +x^2 +2x+1 \pmod{p}.\\
$$


就能得到 Bob 的明文 $m(x)=-x^5+x^3+x^2-x+1.$



### 7.10.2 NTRU加密的数学问题

之前提到，公钥 $h(x)$ 的系数在模 $q$ 的意义下看起来是随机的，但这里也存在一个隐藏的关系：

$$
f(x)\star h(x)\equiv g(x)\pmod{q},\\
$$


其中 $f(x)$ 和 $g(x)$ 的系数都非常小。因此通过寻找私钥来破解 NTRU 就变成了解决下面的问题：

![](https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/v2-dff8869d1561afec7a4ceca4a36c0f07_1440w.jpg)

图 2. NTRU 密钥恢复问题，源自《An Introduction to Mathematical Cryptography》

_Remark 7.54._ NTRU 密钥恢复问题的解并不是唯一的，因为如果 $(f(x),g(x))$ 是一个解的话，那么 $(x^k\star f(x),x^k\star g(x))$ 也是一个解，其中 $0\leq k<N$。多项式 $x^k\star f(x)$ 称为 $f(x)$ 的一个旋转(rotation)，因为其系数被循环移动了 $k$ 个位置。从某种意义上说，旋转充当了私有解密密钥，因为用 $x^k \star f(x)$ 进行解密会得到旋转后的明文 $x^k \star m(x)$。

更一般地，任何有着足够小系数的多项式对 $(f(x),g(x))$，且满足上面的隐藏关系式的都能作为 NTRU 的一个解密密钥。例如，如果 $f(x)$ 是原始的解密密钥且 $\theta(x)$ 的系数非常小，则 $\theta(x)\star f(x)$ 可能也是一个解密密钥。

_Remark._ 为什么人们会认为 NTRU 密钥恢复问题是一个难解的数学问题？首先必须满足的一个要求是，该问题无法通过暴力破解(brute-force)或碰撞搜索(collision search)在实际中解决。我们将在本节后面讨论此类搜索。更重要的是，在后面一节中，我们证明了解决 NTRU 密钥恢复问题(几乎可以肯定)等同于解决某类格中的 SVP 问题。这将 NTRU 问题与一个研究得很好的问题联系起来，尽管是针对一类特殊的格。目前，使用格约化(lattice reduction)是从公钥中恢复 NTRU 私钥的最佳方法。格约化是最好的方法吗？正如整数分解和其他密码系统所依赖的各种离散对数问题一样，没有人能确定是否存在更快的算法。因此，判断 NTRU 密钥恢复问题难度的唯一方法是目前它已经被数学界和密码学界深入地研究了。然后通过应用当前已知最快的算法，可以定量估计解决该问题的难度。

如果 Eve 尝试对所有可能的私钥进行暴力搜索，这会有多难呢？注意，Eve 可以通过验证 $f(x) \star h(x) \pmod q$ 是否为三元多项式来确定她是否找到了私钥 $f(x)$。很有可能，唯一具有此属性的多项式是 $f(x)$ 的旋转，但如果 Eve 恰好找到另一个具有此属性的三元多项式，它也可以用作解密密钥。

于是，我们需要计算三元多项式集合的大小。我们可以首先选择 $d_1$ 个系数为 1，再从剩余的系数中选择 $d_2$ 个为 -1，从而确定 $\mathcal{T}(d_1,d_2)$ 元素的个数。

$$
\#\mathcal{T}(d_1,d_2)={N\choose d_1}{N-d_1\choose d_2}=\frac{N!}{d_1!d_2!(N-d_1-d_2)!}.\\
$$


上式去到最大值时当 $d_1=d_2=N/3$。

对于暴力搜索方法，Eve 必须尝试 $\mathcal{T}(d+1,d)$ 中每个多项式，直到找到解密密钥，但注意到 $f(x)$ 的旋转都是解密密钥，所以共有 $N$ 个可能结果。因此 Eve 大约要做 $\#\mathcal{T}(d+1,d)/N$ 次尝试。



_Example 7.56._ 我们考虑下面这种 NTRU：

$$
(N,p,q,d) = (251,3,257,83).\\
$$


这个 NTRU 参数组合并不满足 $q>(6d+1)p$ 的要求，所以会有解密失败的可能。Eve 期望的搜索次数大约是：

$$
\frac{\mathcal{T}(84,83)}{251}=\frac{1}{251}{251\choose 84}{167\choose 83}\approx 2^{381.6}.\\
$$


> 教材这里还简单介绍了如何使用碰撞算法，但我实在没看懂。。。不过根据生日攻击的原理，大约需要 $\sqrt{2^{381.6}}\approx2^{190.8} $ 次搜索，也能得到相同的结论。

总的来说，我们令 $d\approx N/3$ 使 $\mathcal{T}(d+1,d)$ 取得最大值，并利用 Stirling 公式来估计碰撞搜索的次数：

$$
\#\mathcal{T}(d_1,d_2)\approx\frac{N!}{((N/3!))^3}\approx\left(\frac{N}{e}\right)^N\cdot\left(\left(\frac{N}{3e}\right)^{N/3}\right)^{-3}\approx 3^N.\\
$$


在这种情况下，碰撞搜索大约需要 $O(3^{N/2}/\sqrt{N})$ 次。



_Remark 7.57._ 前面说到，只有$f(x)$ 与其旋转有可能是 $\mathcal{T}(d+1,d)$ 的解密密钥。为了说明这一点，我们要求的是一些随机的 $f(x)\in \mathcal{T}(d+1,d)$ 具有以下性质的概率

$f(x)\star h(x) \pmod q\quad\text{is a ternary polynomial}.\\$

将上式的系数视为独立随机变量，且在模 $q$ 意义下均匀分布。任何特定系数为三元的概率为 $3/q$，因此每个系数都是三元的概率近似为 $(3/q)^N$。所以：

$$
\begin{align}\left(\begin{array}\\\text{Expected number of decryption}\\\text{keys in }\mathcal{T}(d+1,d)\end{array}\right)&\approx \Pr\left(\begin{array}\\f(x)\in\mathcal{T}(d+1,d)\\\text{is a decryption key}\end{array}\right)\times \#\mathcal{T}(d+1,d)\\&=(\frac{3}{q})^N {N\choose d+1}{N-d-1\choose d}.\end{align}\\
$$


回到 $\mathcal{T}(84,83)$ 的例子里，$N=251,q=257$，那么：

$$
(\frac{3}{257})^N {251\choose 84}{167\choose 83}\approx2^{-1222.02}.\\
$$


当然，如果 $h(x)$ 是 NTRU 的公钥，则一定存在解密密钥，因为 $h(x)$ 就是由 $f(x)$ 构造得到的。但是上式计算得到的概率使得除了 $f(x)$ 与其旋转之外，不可能再由其他的解密密钥了。



