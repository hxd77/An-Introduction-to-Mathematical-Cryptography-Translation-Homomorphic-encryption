## 7.7 基于困难格问题的密码系统

在20世纪90年代中期，几个基于高维格 $L$ 的密码系统被提出，其底层的困难问题为[最短向量问题](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=%E6%9C%80%E7%9F%AD%E5%90%91%E9%87%8F%E9%97%AE%E9%A2%98&zhida_source=entity)(SVP)和/或[最近向量问题](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=%E6%9C%80%E8%BF%91%E5%90%91%E9%87%8F%E9%97%AE%E9%A2%98&zhida_source=entity)(CVP)。其中最重要的有：Ajtai-Dwork 密码系统，由 Goldreich、Goldwasser 和 Halevi 提出的 GGH 密码系统，以及由 Hoffstein、Pipher 和 Silverman 提出的 NTRU 密码系统。

引入这些密码系统的动机有两个方面。首先，基于各种难解的数学问题的密码系统无疑是有意义的，因为如果一个数学难题被破解，并不会影响所有系统的安全性。其次，基于格的密码系统通常比基于分解问题或离散对数问题的密码系统更快，如 [ElGamal](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=ElGamal&zhida_source=entity)、[RSA](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=RSA&zhida_source=entity) 和 [ECC](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=ECC&zhida_source=entity)。粗略地说，为了达到 $k$ 比特的安全性，ElGamal、RSA 和 ECC 的加密和解密需要 $O(k^3)$ 次运算，而基于格的系统只需要 $O(k^2)$​ 次运算。此外，基于格的系统所使用的简单线性代数运算在硬件和软件中非常容易实现。然而，目前我们对基于格的密码系统的安全性分析还远未像对基于分解和离散对数的系统那样得到充分的理解。因此，尽管基于格的系统是当前研究的热点，但与前面的密码系统相比，它们在实际中的应用还很少。

Ajtai 和 Dwork 证明了他们的 Ajtai-Dwork 系统是可证明安全的，除非最坏情况下的格问题可以在多项式时间内解决。与这一重要的理论结果相对的是一个实际限制，即密钥大小需要为 $O(n^4)$，这会导致密钥非常庞大。Nguyen 和 Stern 随后证明，任何实用且高效的 Ajtai-Dwork 系统实现都是不安全的。

GGH 密码系统的基本原理(我们将在后面作更详细地解释)是对我们已经讨论过的思想的直接应用。Alice 的私钥是格 $L$ 的一个好的基底 $\mathcal{B}_\text{good}$，而她的公钥是 $L$ 的一个坏的基底 $\mathcal{B}_\text{bad}$。Bob 的消息是一个二进制向量 $m$，用来形成 $\mathcal{B}_\text{bad}$ 中向量的线性组合 $\sum m_iv_i^{\text{bad}}$。然后，他通过添加一个小的随机向量 $r$ 来扰动这个和。由此产生的向量 $w$ 与格向量 $v$ 之间的差异为向量 $r$。由于 Alice 知道 $L$ 的一个好的基，她可以使用 [Babai 的算法](https://zhida.zhihu.com/search?content_id=243056810&content_type=Article&match_order=1&q=Babai+%E7%9A%84%E7%AE%97%E6%B3%95&zhida_source=entity)来找到 $v$，然后用坏的基表示 $v$ 以恢复 $m$。另一方面，Eve 只知道坏的基 $\mathcal{B}_\text{bad}$，所以她无法在 $L$​ 中求解 CVP。

GGH 密码系统中的公钥是格 $L$ 的一个坏的基，因此它由 $n^2$ 个(大)数组成。在最初的版本中，密钥大小为 $O(n^3\log n)$，但使用 Micciancio 的一个想法后，可以将密钥大小减小到 $O(n^2\log n)$ 比特。

Goldreich、Goldwasser 和 Halevi 推测，对于 $n>300$，GGH 所依赖的 CVP 是难以解决的。然而在当时，LLL 类型的格约化算法在高维格上的有效性还没有被仔细研究。Nguyen 表明，对原始 GGH 加密方案的转换可以将问题简化为一个更容易的 CVP。这使他能够解决提出的维数高达 350 的 GGH 挑战问题。对于 $n>400$，公钥大约为 128 KB。

NTRU 公钥密码系统很自然地用多项式商环来描述。然而，NTRU 所基于的困难问题很容易转化为一类特殊格中的 SVP(用于密钥恢复)或 CVP(用于明文恢复)。NTRU 格(将在后面讲述)是偶数维 $n=2N$ 的格，由所有满足

$y\equiv xH\ (\text{mod}\ q)\\$

的向量 $(x,y) \in \mathbb{Z}^{2N}$ 组成，其中 $q$ 是一个固定的正整数，也是一个公共参数，在实际中，$q = O(n)$。矩阵 $H$ 是公钥，是一个 $N\times N$ 的循环矩阵。这意味着 H 的每一行都是前一行的循环移位，于是为了描述 $H$，只需指定其第一行即可。因此，公钥的大小为 $O(n\log n)$，明显小于 GGH。

NTRU 的私钥是一个短向量 $(f,g)\in L$。由短向量 $(f,g)$ 及其部分循环移位组成的集合在 $L$ 中给出了 $N = \frac{1}{2} \dim(L)$ 个独立的短向量。这使得 $(f,g)$ 的所有者能够在 $L$ 中求解 CVP 的某些实例，从而恢复加密的明文。因此，明文的安全性依赖于在 NTRU 格中求解 CVP 的难度。此外，向量 $(f,g)$ 及其循环移位几乎可以肯定地说是 $L$ 中最短的非零向量，因此 NTRU 也容易受到 SVP 解的攻击。