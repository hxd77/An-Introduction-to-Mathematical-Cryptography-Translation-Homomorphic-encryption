## 7.6 Babai's 算法 和 使用一个好基去解决 apprCVP

如果格 $L \subset \mathbb{R}^n$ 有组相互正交的基 $v_1,\dots,v_n$，即满足：

$$
v_i \cdot v_j = 0 \quad\text{for all }i\neq j,\\
$$
则我们可以轻松解决 SVP 和 CVP。为解决 SVP，我们观察到 $L$ 中的任何向量的长度都由下面公式给出：

$$
\left\lVert a_1v_1+\dots+a_nv_n\right\rVert^2=a_1^2\left\lVert v_1 \right\rVert^2+\dots+a_n^2\left\lVert v_n \right\rVert^2.\\
$$
因为 $a_1,\dots,a_n\in \mathbb{Z}$，所以 $L$ 中的最短非零向量就是集合 $\{\pm v_1,\dots,\pm v_n\}$ 中的最短向量。即

$$
v_{\text{shortest}}=\{v_i:\ \left\lVert v_i \right\rVert=\min\{\left\lVert v_1 \right\rVert, \dots, \left\lVert v_n \right\rVert\} \}\\
$$
类似地可以解决 CVP。我们想要寻找 $L$ 中的一个最短向量，使其与给定向量 $w\in \mathbb{R}^n$ 的距离最近。我们首先将 $w$ 表示为：

$$
w=t_1v_1+\dots+t_nv_n \quad \text{with }t_1,\dots,t_n\in \mathbb{R}.\\
$$
那么对于 $v=a_1v_1+\dots+a_nv_n \in L$，我们有：

$$
\left\lVert v-w \right\rVert^2=(a_1-t_1)^2\left\lVert v_1 \right\rVert^2+\dots+(a_n-t_n)^2\left\lVert v_n \right\rVert^2.\\
$$
$a_i$ 是整数，因此上式要想取得最小值，我们只需将每个 $a_i$ 设置为与相应的 $t_i$ 最为接近的整数即可。

如果基中的向量是相互正交的，那么我们很有可能能够成功解决 CVP；但是如果基向量高度不正交，那么该算法就不会运行得很好。我们简要讨论一下潜在的几何原理，然后描述一般的方法，最后以一个二维的例子作结。

$L$ 的一组基确定了一个基本域 $\mathcal{F}$，我们在基本域一节已经证明了：用 $L$ 中的元素对 $\mathcal{F}$ 进行平移将会得到整个 $\mathbb{R}^n$ 空间，因此任何 $w\in \mathbb{R}^n$ 都有 $\mathcal{F}$ 的唯一一个平移 $\mathcal{F}+v,\ v\in L$。我们将平行六面体(parallelepiped) $L+v$ 中最靠近 $w$ 的顶点(vertex)作为我们对 CVP 的假设解。找到最近的顶点其实是很容易，因为：

$w=v+\epsilon_1v_1+\epsilon_2v_2+\dots+\epsilon_nv_n\quad \text{for some }0\leq \epsilon_1,\epsilon_2,\dots,\epsilon_n <1,\\$

则我们只需对 $\epsilon_i$ 进行如下替换：

$\epsilon_i = \left\{\begin{aligned}0,&\quad \text{if }\ \epsilon_i<\frac{1}{2}\\1,&\quad \text{if }\ \epsilon_i\geq\frac{1}{2}\\\end{aligned}\right.\\$

下图展示了整个过程：



图 2. 尝试用给定的基本域来求解 CVP，源自《An Introduction to Mathematical Cryptography》


观察图 2，看上去这个过程一定有效，但这是因为图中的基向量彼此相对较为正交(reasonably orthogonal to one another)。图 3 说明了同一个格内的两组不同的基。第一个基是“好的(good)”，因为这些向量相当正交(fairly orthogonal)；第二个基是“坏的(bad)”，因为基向量之间的角度非常小。

![](https://pic3.zhimg.com/v2-e82abbf0951c90ba2324da2d86ce38d6_1440w.jpg)

图 3. 同一个格的两组不同的基，源自《An Introduction to Mathematical Cryptography》


如果我们尝试使用一个坏的基来求解 CVP，就像图 4 所示，我们可能会遇到问题。非格点的目标点实际上非常接近一个格点(见图 4 中的 Target Point 与 Closest Lattice Point)，但由于平行四边形过于细长，最靠近目标点的顶点实际上相当远(Target Point 与 Closest Vertex)。需要注意的是，随着格的维度增加，这些困难会变得更加严重。在二维或三维，甚至四维或五维中可视化的例子，并不能充分展示在基不够正交的情况下，最近顶点算法在解决 CVP 甚至是 apprCVP 上的失败程度。

![](https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/v2-c67ab4f68f3fa2286a3de21b22c6ef13_1440w.jpg)

图 4. 对于“坏的”基，Babai algorithm 的效果会很差。源自《An Introduction to Mathematical Cryptography》

  

**Theorem (Babai's Closest Vertex Algorithm).** 设 $L \subset \mathbb{R}^n$ 是一个 $n$ 维的 lattice，$v_1,\dots,v_n$ 是其一组基，令 $w$ 是 $\mathbb{R}^n$​ 中任意的一个向量。如果基底中的向量相互足够正交，那么我们有以下算法来解决 CVP。

![](https://cdn.jsdelivr.net/gh/hxd77/BlogImage/Blog/v2-aa570079f49ddf4578b220bd981e1206_1440w.jpg)

图 5. Babai algorithm。源自《An Introduction to Mathematical Cryptography》

> $\lfloor t_i\rceil$ 符号表示对 $t_i$ 四舍五入为整数。

一般来说，如果基中的向量彼此较为正交，那么该算法可以解决某种形式的 apprCVP。但是，如果基向量高度非正交，那么算法返回的向量通常与 $w$​ 相距甚远。

_Example._ 设 $L \subset \mathbb{R}^2$ 是一个 2 维的 lattice。我们给定一组基：

$v_1=(137,312) \quad \text{and}\quad v_2=(215,-187).\\$

我们将用 Babai's algorithm 来寻找 $L$ 的一个向量，使其与下面的向量最为接近：

$w=(53172, 81743).\\$

首先我们将 $w$ 表示为 $v_1,v_2$ 的实系数线性组合的形式。即我们需要寻找 $t_1, t_2 \in \mathbb{R}$ 满足：

$w = t_1 v_1+t_2v_2.\\$

我们可以得到两个线性方程：

$53172=137t_1+215t_2 \quad \text{and} \quad 81743=312t_1-187t_2.\\$

或者我们可以用矩阵的形式表示，

$(53172,81743)=(t_1,t_2)\left(\begin{array}1137 & 312\\215 &-187\\\end{array}\right).\\$

不管哪种方式，我们都能很轻易地计算 $(t_1,t_2)$。最后求出 $t_1\approx296.85,\ t_2\approx 58.15$。Babai's algorithm 告诉我们将 $t_1,\ t_2$ 圆整(round，即四舍五入)到最近的整数，然后计算：

$\begin{aligned}v&=\lfloor t_1\rceil v_1+\lfloor t_2\rceil v_2\\&=297\cdot(137,312)+58\cdot(215,-187)\\&=(53159,81818).\end{aligned}\\$

$v\in L$ 且 $v$ 应该接近于 $w$。我们发现：

$\left\lVert v-w \right\rVert \approx 76.12\\$

的确足够小。这是可以预测的，因为给定基中的向量彼此相当正交，这一点可以从 Hadamard 比率就可以看出：

$\mathcal{H}(v_1,v_2)=\left(\frac{\det(L)}{\left\lVert v_1\right\rVert \left\lVert v_2\right\rVert} \right)^{1/2}\approx \left(\frac{92699}{340.75 \times 284.95}\right)^{1/2}\approx 0.977\\$

非常接近于 1.

我们现在尝试用一组新的基来解决同样的问题：

$v_1^{'}=(1975,438)=5v_1+6v_2 \quad\text{and}\quad v_2^{'}=(7548,1627)=19v_1+23v_2.\\$

线性方程组

$(53172,81743)=(t_1,t_2)\left(\begin{array}11975 & 438\\7548 & 1627\\\end{array}\right)\\$

的解为 $(t_1,t_2)\approx (5722.66,-1490.34)$，于是我们令：

$v^{'}=5723v_1^{'}-1490v_2^{'}=(56405,82444).\\$

则 $v^{'}\in L$，但 $v^{'}$ 并没有足够接近 $w$，因为：

$\left\lVert v^{'}-w \right\rVert \approx 3308.12.\\$

基底 $\{v_1^{'},v_2^{'}\}$ 的非正交性也反映在 Hadamard 比率上：

$\mathcal{H}(v_1^{'},v_2^{'})=\left(\frac{\det(L)}{\left\lVert v_1^{'}\right\rVert \left\lVert v_2^{'}\right\rVert} \right)^{1/2}\approx \left(\frac{92699}{2022.99 \times 7721.36}\right)^{1/2}\approx 0.077\\$





