## 1.3 模算术

**Definition.**

我们写
$$
\mathbb{Z}/m\mathbb{Z}=\{0,1,2,\ldots,m-1\}
$$
**并称$\mathbb{Z}/m\mathbb{Z}$为模$m$的整数环**。我们对$\mathbb{Z}/m\mathbb{Z}$中的元素进行加法和乘法运算时，**先将它们作为整数进行加或乘，然后将结果除以$m$并取余数，以得到$\mathbb{Z}/m\mathbb{Z}$中的一个元素。**

图1.4通过给出完整的模5加法表和乘法表，对环$\mathbb{Z}/5\mathbb{Z}$进行了说明。

![image-20250930165601968](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20250930165601998.png)

Remark 1.16. 如果你学过环论，就会知道$\mathbb{Z}/m\mathbb{Z}$是 $\mathbb{Z}$ 对主理想 $m\mathbb{Z}$ 的商环，而数字$0,1,\ldots,m-1$实际上是构成$\mathbb{Z}/m\mathbb{Z}$元素的同余类的陪集代表元。关于同余类和一般商环的讨论，请参见2.10.2节。

**Definition.** Proposition 1.13（b）告诉我们，$a$存在模$m$的逆元当且仅当 $gcd（a，m）=1$。存在逆元的数被称为 $units$。我们用如下来表示所有$units$组成的集合。
$$
\begin{aligned}(\mathbb{Z}/m\mathbb{Z})^{*}&=\{a\in\mathbb{Z}/m\mathbb{Z}:\gcd(a,m)=1\}\\&=\{a\in\mathbb{Z}/m\mathbb{Z}:a\text{ has an inverse modulo }m\}.\end{aligned}
$$
**集合$\mathbb{Z}/m\mathbb{Z}^{*}$被称为模$m$的 $units$ (群)。**

注意，如果$a_1$和$a_2$是模$m$的$units$，那么$a_1a_2$也是（你明白为什么会这样吗？）。所以，当我们将两个单位相乘时，得到的结果始终是一个$units$。而另一方面，当我们将两个单位相加时，得到的结果往往不是一个$units$。



Example 1.17. 模24的 $ units$ 群是
$$
(\mathbb{Z}/24\mathbb{Z})^*=\{1,5,7,11,13,17,19,23\}.
$$
同样地，模7的 $units$ 群是
$$
(\mathbb{Z}/7\mathbb{Z})^*=\{1,2,3,4,5,6\},
$$
**因为1到6之间的每个数都与7互质**。$\mathbb{Z}/24\mathbb{Z}$ 和 $\mathbb{Z}/7\mathbb{Z}$的乘法表如图1.5所示。

![image-20250930222255499](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20250930222255531.png)

**Definition.** 欧拉$\phi$函数（有时也称为欧拉 Totient 函数）是由以下规则定义的函数$\phi(m)$
$$
\phi(m)=\#\left(\mathbb{Z}/m\mathbb{Z}\right)^*=\#\{0\leq a<m:\gcd(a,m)=1\}.
$$
例如，我们从例1.17中可以看到 $\phi{(24)}=8$ 且 $\phi{(7)}=6$ (与$m$互素的个数)

### 1.3.1 模运算与移位密码

回想一下，在1.1节中研究的凯撒（或移位）密码的工作原理是将字母表中的每个字母都向后移动固定数量的字母。我们可以通过像表1.7中那样给每个字母分配一个数字，从数学角度来描述移位密码。

![image-20251002163355546](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002163402610.png)

那么，一个移位为 $k$ 的移位密码会将对应数字 $p$ 的明文字母转换为对应数字 $p+k$ 模 $26$ 的密文字母。注意，在这种情况下，模26运算的使用简化了移位密码的描述。**移位量既作为加密密钥，也作为解密密钥**。加密由以下公式给出
$$
\text{(Ciphertext Letter)}\equiv\text{(Plaintext Letter)}+\text{(Secret Key)}({\mathrm{mod}}26),
$$
而解密则通过向相反方向移位来实现，
$$
\text{(Plaintext Letter)}\equiv\text{(Ciphertext Letter)}-\text{(Secret Key)}({\mathrm{mod}}26).
$$
更简洁地说，如果我们令
$$
p = \text{Plaintext Letter}, \qquad c = \text{Ciphertext Letter}, \qquad k = \text{Secret Key}
$$
那么
$$
\underbrace{c \equiv p + k \pmod{26}}_{\text{Encryption}} \qquad \text{and} \qquad \underbrace{p \equiv c - k \pmod{26}}_{\text{Decryption}}.
$$


### 1.3.2 快速幂算法

在我们将要研究的一些密码系统中，例如RSA和Diffie-Hellman密码系统，爱丽丝和鲍勃需要计算一个数 $g$ 对另一个数 $N$ 取模的大幂次，其中$N$可能有数百位。计算$g^A$的朴素方法是通过反复乘以$g$。因此
$$
g_1\equiv g({\mathrm{mod}}N),\quad g_2\equiv g\cdot g_1({\mathrm{mod}}N),\quad g_3\equiv g\cdot g_2({\mathrm{mod}}N),\\
\quad g_4\equiv g\cdot g_3({\mathrm{mod}}N),\quad g_5\equiv g\cdot g_4({\mathrm{mod}}N),\ldots
$$
显然，$g_{A}\equiv g^{A}({\mathrm{mod}} N),$，但如果$A$很大，这种算法就完全不实用了。例如，若$A\approx2^{1000}$，那么这种朴素算法所需的时间会比宇宙的估计年龄还要长！显然，要让它有用，我们需要找到一种更好的方法来计算$g^{A}({\mathrm{mod}}N).$

其思路是利用指数$A$的二进制展开式，将$g^A$的计算转化为一系列的平方运算和乘法运算。我们先通过一个例子来阐明这个思路，之后再对该方法进行正式描述。

Example 1.18. 假设我们想计算$3^{218}({\mathrm{mod}}\ 1000)$。第一步是将218写成2的幂的和，
$$
\begin{array}{c}218=2+2^3+2^4+2^6+2^7.\end{array}
$$
然后$3^{218}$变成：
$$
3^{218}=3^{2+2^3+2^4+2^6+2^7}=3^2\cdot3^{2^3}\cdot3^{2^4}\cdot3^{2^6}\cdot3^{2^7}.\tag{1.3}
$$
请注意，计算这一系列值相对容易。
$$
\begin{array}{ccccc}3,&3^2,&3^{2^2},&3^{2^3},&3^{2^4},\ldots,\end{array}
$$
因为**序列中的每个数字都是前一个数字的平方**（跟3没关系，主要是2的次方）。此外，由于我们只需要这些值对1000取模的结果，所以我们永远不需要存储超过三位数字。表1.8列出了3的幂对1000取模的结果，一直到3的27次幂。尽管3的27次幂这个数的指数相当大，但创建表1.8只需要7次乘法，因为表中每个后续的条目都等于前一个条目的平方。

![image-20251002164752550](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002164752574.png)

我们使用（1.3）来确定需要表1.8中的哪些幂来计算$3^{218}$。因此
$$
\begin{aligned}3^{218}&=3^{2}\cdot3^{2^{3}}\cdot3^{2^{4}}\cdot3^{2^{6}}\cdot3^{2^{7}}\\&\equiv9\cdot561\cdot721\cdot281\cdot961({\mathrm{mod}}1000)\\&\equiv489({\mathrm{mod}}1000).\end{aligned}
$$
我们注意到，在计算乘积 $9·561·721·281·961$ 时，我们可以在每次乘法后对1000取模，这样就永远不必处理非常大的数。我们还观察到，计算 $3^{218}({\mathrm{mod}}\ 1000)$ 只需要11次乘法，这比朴素方法节省了大量运算。而且对于更大的指数，我们节省的运算量会更多。

例1.18中使用的通用方法有多种名称，包括快速幂算法和平方-乘算法。我们现在更正式地描述该算法。
$$
\boxed{\quad\text{The Fast Powering Algorithm}\quad}
$$
**Step 1.** 计算 $A$ 的二进制展开式，如下所示：
$$
A = A_{0} + A_{1} \cdot 2 + A_{2} \cdot 2^{2} + A_{3} \cdot 2^{3} + \cdots + A_{r} \cdot 2^{r} \quad \text { with } A_{0}, \ldots, A_{r} \in\{0,1\},
$$
其中我们假设 $A_{r}=1$.

**Step 2.**






