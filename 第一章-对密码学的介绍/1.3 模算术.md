## 1.3 模算术

**Definition.**

我们写
$$
\mathbb{Z}/m\mathbb{Z}=\{0,1,2,\ldots,m-1\}
$$
并称$\mathbb{Z}/m\mathbb{Z}$为模$m$的整数环。我们对$\mathbb{Z}/m\mathbb{Z}$中的元素进行加法和乘法运算时，**先将它们作为整数进行加或乘，然后将结果除以$m$并取余数，以得到$\mathbb{Z}/m\mathbb{Z}$中的一个元素。**

图1.4通过给出完整的模5加法表和乘法表，对环$\mathbb{Z}/5\mathbb{Z}$进行了说明。

![image-20250930165601968](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20250930165601998.png)

Remark 1.16. 如果你学过环论，就会知道$\mathbb{Z}/m\mathbb{Z}$是 $\mathbb{Z}$ 对主理想 $m\mathbb{Z}$ 的商环，而数字$0,1,\ldots,m-1$实际上是构成$\mathbb{Z}/m\mathbb{Z}$元素的同余类的陪集代表元。关于同余类和一般商环的讨论，请参见2.10.2节。

**Definition.** Proposition 1.13（b）告诉我们，$a$存在模$m$的逆元当且仅当 $gcd（a，m）=1$。存在逆元的数被称为 $units$。我们用如下来表示所有$units$组成的集合。
$$
\begin{aligned}(\mathbb{Z}/m\mathbb{Z})^{*}&=\{a\in\mathbb{Z}/m\mathbb{Z}:\gcd(a,m)=1\}\\&=\{a\in\mathbb{Z}/m\mathbb{Z}:a\text{ has an inverse modulo }m\}.\end{aligned}
$$
**集合$\mathbb{Z}/m\mathbb{Z}^{*}$被称为模$m$的 $units$ (群)。**

注意，如果$a_1$和$a_2$是模$m$的$units$，那么$a_1a_2$也是（你明白为什么会这样吗？）。所以，当我们将两个单位相乘时，得到的结果始终是一个$units$。而另一方面，当我们将两个单位相加时，得到的结果往往不是一个$units$。



Example 1.17. 模24的 $ units$ 群是
$$
(\mathbb{Z}/24\mathbb{Z})^*=\{1,5,7,11,13,17,19,23\}.
$$
同样地，模7的 $units$ 群是
$$
(\mathbb{Z}/7\mathbb{Z})^*=\{1,2,3,4,5,6\},
$$
**因为1到6之间的每个数都与7互质**。$\mathbb{Z}/24\mathbb{Z}$ 和 $\mathbb{Z}/7\mathbb{Z}$的乘法表如图1.5所示。

![image-20250930222255499](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20250930222255531.png)

**Definition.** 欧拉$\phi$函数（有时也称为欧拉 Totient 函数）是由以下规则定义的函数$\phi(m)$
$$
\phi(m)=\#\left(\mathbb{Z}/m\mathbb{Z}\right)^*=\#\{0\leq a<m:\gcd(a,m)=1\}.
$$
例如，我们从例1.17中可以看到 $\phi{(24)}=8$ 且 $\phi{(7)}=6$ (与$m$互素的个数)

### 1.3.1 模运算与移位密码

回想一下，在1.1节中研究的凯撒（或移位）密码的工作原理是将字母表中的每个字母都向后移动固定数量的字母。我们可以通过像表1.7中那样给每个字母分配一个数字，从数学角度来描述移位密码。

![image-20251002163355546](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002163402610.png)

那么，一个移位为 $k$ 的移位密码会将对应数字 $p$ 的明文字母转换为对应数字 $p+k$ 模 $26$ 的密文字母。注意，在这种情况下，模26运算的使用简化了移位密码的描述。**移位量既作为加密密钥，也作为解密密钥**。加密由以下公式给出
$$
\text{(Ciphertext Letter)}\equiv\text{(Plaintext Letter)}+\text{(Secret Key)}({\mathrm{mod}}26),
$$
而解密则通过向相反方向移位来实现，
$$
\text{(Plaintext Letter)}\equiv\text{(Ciphertext Letter)}-\text{(Secret Key)}({\mathrm{mod}}26).
$$
更简洁地说，如果我们令
$$
p = \text{Plaintext Letter}, \qquad c = \text{Ciphertext Letter}, \qquad k = \text{Secret Key}
$$
那么
$$
\underbrace{c \equiv p + k \pmod{26}}_{\text{Encryption}} \qquad \text{and} \qquad \underbrace{p \equiv c - k \pmod{26}}_{\text{Decryption}}.
$$


### 1.3.2 快速幂算法

在我们将要研究的一些密码系统中，例如RSA和Diffie-Hellman密码系统，爱丽丝和鲍勃需要计算一个数 $g$ 对另一个数 $N$ 取模的大幂次，其中$N$可能有数百位。计算$g^A$的朴素方法是通过反复乘以$g$。因此
$$
g_1\equiv g({\mathrm{mod}}N),\quad g_2\equiv g\cdot g_1({\mathrm{mod}}N),\quad g_3\equiv g\cdot g_2({\mathrm{mod}}N),\\
\quad g_4\equiv g\cdot g_3({\mathrm{mod}}N),\quad g_5\equiv g\cdot g_4({\mathrm{mod}}N),\ldots
$$
显然，$g_{A}\equiv g^{A}({\mathrm{mod}} N),$，但如果$A$很大，这种算法就完全不实用了。例如，若$A\approx2^{1000}$，那么这种朴素算法所需的时间会比宇宙的估计年龄还要长！显然，要让它有用，我们需要找到一种更好的方法来计算$g^{A}({\mathrm{mod}}N).$

其思路是利用指数$A$的二进制展开式，将$g^A$的计算转化为一系列的平方运算和乘法运算。我们先通过一个例子来阐明这个思路，之后再对该方法进行正式描述。

Example 1.18. 假设我们想计算$3^{218}({\mathrm{mod}}\ 1000)$。第一步是将218写成2的幂的和，
$$
\begin{array}{c}218=2+2^3+2^4+2^6+2^7.\end{array}
$$
然后$3^{218}$变成：
$$
3^{218}=3^{2+2^3+2^4+2^6+2^7}=3^2\cdot3^{2^3}\cdot3^{2^4}\cdot3^{2^6}\cdot3^{2^7}.\tag{1.3}
$$
请注意，计算这一系列值相对容易。
$$
\begin{array}{ccccc}3,&3^2,&3^{2^2},&3^{2^3},&3^{2^4},\ldots,\end{array}
$$
因为**序列中的每个数字都是前一个数字的平方**（跟3没关系，主要是2的次方）。此外，由于我们只需要这些值对1000取模的结果，所以我们永远不需要存储超过三位数字。表1.8列出了3的幂对1000取模的结果，一直到3的27次幂。尽管3的27次幂这个数的指数相当大，但创建表1.8只需要7次乘法，因为表中每个后续的条目都等于前一个条目的平方。

![image-20251002164752550](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002164752574.png)

我们使用（1.3）来确定需要表1.8中的哪些幂来计算$3^{218}$。因此
$$
\begin{aligned}3^{218}&=3^{2}\cdot3^{2^{3}}\cdot3^{2^{4}}\cdot3^{2^{6}}\cdot3^{2^{7}}\\&\equiv9\cdot561\cdot721\cdot281\cdot961({\mathrm{mod}}1000)\\&\equiv489({\mathrm{mod}}1000).\end{aligned}
$$
我们注意到，在计算乘积 $9·561·721·281·961$ 时，我们可以在每次乘法后对1000取模，这样就永远不必处理非常大的数。我们还观察到，计算 $3^{218}({\mathrm{mod}}\ 1000)$ 只需要11次乘法，这比朴素方法节省了大量运算。而且对于更大的指数，我们节省的运算量会更多。

例1.18中使用的通用方法有多种名称，包括快速幂算法和平方-乘算法。我们现在更正式地描述该算法。
$$
\boxed{\quad\text{The Fast Powering Algorithm}\quad}
$$
**Step 1.** 计算 $A$ 的二进制展开式，如下所示：
$$
A = A_{0} + A_{1} \cdot 2 + A_{2} \cdot 2^{2} + A_{3} \cdot 2^{3} + \cdots + A_{r} \cdot 2^{r} \quad \text { with } A_{0}, \ldots, A_{r} \in\{0,1\},
$$
其中我们假设 $A_{r}=1$.

**Step 2.**





## 1.4 质数、唯一分解以及有限域

在1.3节中，我们学习了模算术，并了解到对整数进行模 $m$ 的加、减和乘法运算都是有意义的。然而，除法可能会存在问题，因为只有当$\gcd（a，m）=1$时，我们才能在$\mathbb{Z}/m\mathbb{Z}$中除以$a$。但需要注意的是，如果整数$m$是一个质数，那么我们就可以除以$\mathbb{Z}/m\mathbb{Z}$中的每一个非零元素。在回到$p$为质数的环$\mathbb{Z}/p\mathbb{Z}$之前，我们先简要讨论一下质数。

**Definition.** 如果一个整数 $p$ 满足 $p≥2$ ，且能整除$p$的正整数只有 $1$ 和 $p$ 本身，那么 $p$ 就被称为质数。

例如，前$10$个质数是$2、3、5、7、11、13、17、19、23、29$，而第$10$万个质数是$1299709$，第$100$万个质数是$15485863$。质数有无限多个，这一事实在古希腊就已为人所知，并作为定理出现在欧几里得的《几何原本》中（参见练习1.28）。

一个质数 $p$ 的定义取决于能整除 $p$ 的数。因此，下面这个描述能被 $p$ 整除的数的一个有用性质的命题并不明显，需要仔细证明。注意，这个命题对于合数来说是不成立的。例如，$6$ 能整除 $3·10$，但 $6$ 既不能整除 $3$，也不能整除 $10$ 。

**Proposition 1.19.** 设 $p$ 是一个质数，并且假设 $p$ 能整除两个整数 $a$ 和 $b$ 的乘积 $ab$。那么 $p$ 至少能整除 $a$ 和 $b$ 中的一个。更一般地说，如果 $p$ 能整除整数的一个乘积，比如
$$
p\mid a_1a_2\cdots a_n,
$$
那么 $p$ 至少能整除其中一个单独的 $a_i$。



Proof. 令$g=\gcd(a,p)$。那么$g$能整除$p$，因此 $g$ 要么等于 $1$ ，要么等于 $p$。如果 $g = p$，那么 $p$ 能整除 $a$（因为 $g$ 能整除 $a$），这样我们就完成了证明。否则，$g = 1$，且定理1.11告诉我们，我们可以找到整数 $u$ 和 $v$，使得 $au + pv = 1$ 。我们将等式两边同时乘以 $b$，得到
$$
\begin{array}{c}abu+pbv=b.\end{array}\tag{1.5}
$$
根据假设，$p$ 整除乘积 $ab$，并且显然 $p$ 整除 $pbv$，因此 $p$ 整除（1.5）式左侧的两项。由此可知，$p$ 整除右侧，这表明 $p$ 整除 $b$，从而完成了命题1.19的证明。

为了证明更具一般性的结论，我们将这个乘积写成 $a_1(a_2···a_n)$，并对 $a = a₁$ 和 $b = a_2···a_n$ 应用第一个结论。如果 $p$ 能整除$a_1$，那么我们就完成了证明。否则，$p$ 能整除 $a_2···a_n$，于是将其写成$a_2(a₃···a_n)$ ，第一个结论告诉我们，要么 $p$ 能整除 $a_2$ ，要么 $p$ 能整除 $a_3···a_n$ 。按照这种方式继续下去，我们最终必定能找到某个能被 $p$ 整除的 $a_i$。

作为命题1.19的一个应用，我们证明每个正整数都有一个本质上唯一的素数乘积分解式。



**Theorem 1.20** （算术基本定理）设 $a$ 是大于等于 $2$ 的整数，那么 $a$ 可以分解为素数的乘积。
$$
a=p_1^{e_1}\cdot p_2^{e_2}\cdot p_3^{e_3}\cdot\cdot\cdot p_r^{e_r}.
$$
此外，除了重新排列质数的顺序外，**这种分解为质数幂的方式是唯一的。**



Proof. 不难证明，每个$a\ge 2$ 都可以分解为素数的乘积。人们很容易认为这种分解的唯一性也是显而易见的。然而，事实并非如此；唯一分解性是整数的一个略显微妙的性质。我们将利用命题1.19的一般形式来证明这一点（关于唯一分解性不成立的情况示例，参见文献[137，第7章]中描述的E区）。

假设 $a$ 有两种分解方式，可分解为质数的乘积，
$$
a=p_1p_2\cdots p_s=q_1q_2\cdots q_t,\tag{1.6}
$$
其中 $p_i$ 和 $q_j$均为质数，它们不一定互不相同，且 $s$ 也不一定等于 $t$。由于 $p_1$ 能整除 $a$，我们可知 $p_1$ 能整除乘积 $q_1q_2q_3\cdots q_t$。因此，根据命题1.19的一般形式，我们发现 $p_1$ 能整除其中一个$q_i$。如果有必要，重新排列这些 $q_i$ 的顺序，我们可以假设 $p_1$ 整除 $q_1$。但 $p_1$ 和 $q_1$都是质数，所以我们必定有 $p_1 = q_1$。这使我们能够从（1.6）式的两边消去它们，从而得到
$$
p_2p_3\cdots p_s=q_2q_3\cdots q_t.
$$
重复这个过程 $s$ 次，我们最终会得到一个如下形式的方程
$$
\begin{array}{c}1=q_{t-s}q_{t-s+1}\cdots q_t.\end{array}
$$
由此立即可以得出 $t = s$，并且 $a$ 的原始因式分解除了因子的顺序可以重新排列外是完全相同的。（有关算术基本定理的更详细证明，请参见任何基础数论教科书，例如[35, 52, 59, 100, 111, 137]。）

>每个 $q_j$ 都是素数，所以都大于 $1$。
>
>如果乘积等于 $1$，说明**这个乘积里面没有素数**。
>
>如果 $s<t$，右边至少有一个素数，乘积 $≥ 2$，不可能 $=1$。
>
>如果 $s>t$，符号就不合逻辑（因为因子个数不能是负数）。
>
>唯一可能就是 $s=t$，此时乘积是空积（没有素数相乘），约定值就是 $1$。



**Definition.** 算术基本定理（定理1.20）表明，在将正整数 $a$ 分解为素数的过程中，每个素数 $p$ 都以特定的幂次出现。**我们用 $ord_p(a)$ 来表示这个幂次**，**并称之为 $p$ 在 $a$ 中的阶（或指数）**。（为方便起见，对于所有素数，我们规定 $ord_p(1)=0$。）

例如，$1728$的因式分解是$1728 = 2^6\cdot 3^3$，所以

$$
\mathrm{ord}_2(1728)=6,\mathrm{ord}_3(1728)=3,\mathrm{and}\ \mathrm{ord}_p(1728)=0\text{ for all primes }p\geq5.
$$
使用$\mathrm{ord}_p$符号，可以简洁地写出 $a$ 的因式分解
$$
a=\prod_{\mathrm{primes}\ p}p^{\mathrm{ord}_p(a)}
$$
请注意，这个乘积是有意义的，因为除了有限多个素数外，对于所有其他素数，$\mathrm{ord}_p(a)$ 都是零。将 $\mathrm{ord}_p$ 视为一个函数是很有用的。
$$
\mathrm{ord}_p:\{1,2,3,\ldots\}\longrightarrow\{0,1,2,3,\ldots\}.\tag{1.7}
$$
我们现在注意到，如果 $p$ 是一个质数，那么模 $p$ 的每个非零数都有一个模 $p$ 的乘法逆元。这意味着当我们进行模质数 $p$ 的运算时，我们不仅可以进行加法、减法、乘法运算，还可以对非零数进行除法运算，就像我们对实数进行运算时那样。质数的这一性质非常重要，因此我们将其正式表述为一个命题。



**Proposition 1.21. **设 $p$ 是一个素数。那么在 $\mathbb{Z}/p\mathbb{Z}$ 中，每个非零元素 $a$ 都有一个乘法逆元，即存在一个数 $b$ 满足
$$
ab\equiv1({\mathrm{mod}}\ p).
$$


我们将 $b$ 的这个值记为 $a^{-1}\mathrm{mod}\ p,$，或者如果 $p$ 已经被指定，那么就简单记为 $a^{-1}$。



Proof. 这个命题是命题1.13(b)在素数模 $p$ 情况下的特例，因为如果 $a$ 属于 $\mathbb{Z}/p\mathbb{Z}$ 且不为零，那么$\gcd(a,p)=1$。

Remark 1.22. 扩展欧几里得算法（定理1.11）为我们提供了一种计算 $a^{-1}\mathrm{mod}\ p,$ 的高效计算方法。我们只需解这个方程
$$
au+pv=1\quad\text{in integers}\ u\ \mathrm{and}\ v,
$$
然后 $u=a^{-1}\mathrm{mod}\ p$ 。关于计算 $u=a^{-1}\mathrm{mod}\ p$ 的另一种方法，参见 注1.26。

命题 1.21 **可以重述为：如果 $p$ 是素数，那么**
$$
(\mathbb{Z}/p\mathbb{Z})^*=\{1,2,3,4,\ldots,p-1\}.
$$
**换句话说，当从 $\mathbb{Z}/p\mathbb{Z}$ 中去掉 $0$ 元素后，剩下的元素都是单位元，并且在乘法运算下是封闭的。**



**Definition.** **如果 $p$ 是质数，那么配备了加法、减法、乘法和除法运算规则的整数模 $p$ 的集合 $\mathbb{Z}/p\mathbb{Z}$ 就是一个域的例子**。如果你学过抽象代数（或者参见2.10节），就会知道域是（交换）环的统称，**在这种环中，每个非零元素都有乘法逆元**。你已经熟悉其他一些域了，例如实数域 $\mathbb{R}$、有理数（分数）域$\mathbb{Q}$以及复数域$\mathbb{C}$。

**模 $p$ 整数域 $\mathbb{Z}/p\mathbb{Z}$ 只有有限多个元素。它是一个有限域，通常记为 $\mathbb{F}_q$**。因此，**$\mathbb{F}_q$ 和 $\mathbb{Z}/p\mathbb{Z}$ 实际上只是同一对象的两种不同记法**。类似地，**我们使用 $\mathbb{F}_q^*$ 来表示单位 $units$ $(\mathbb{Z}/p\mathbb{Z})^*$** 。有限域在整个密码学中，乃至在整个数学领域中都具有根本重要性。

Remark 1.23. 尽管 $\mathbb{Z}/p\mathbb{Z}$ 和 $\mathbb{F}_q$ 用于表示相同的概念，但在这两种情况下，元素的相等性表达方式略有不同。对于 $a,b\in\mathbb{F}_{p}$，$a$ 和 $ b$的相等性用 $a = b$ 表示，而对于 $a,b\in\mathbb{Z}/p\mathbb{Z},$，$a$ 和 $b$ 的相等性则用模 $p$ 等价来表示，即 $a\equiv b(\mathrm{mod}\ p).$。



## 1.5 有限域中的幂和原根

有限域在密码学中的应用通常涉及将 $\mathbb{F}_p$中的元素提升到高次幂。实际上，我们知道如何使用1.3.2节中描述的幂运算算法高效地完成这一操作。在本节中我们从纯数学的角度研究有限域 $\mathbb{F}_q$ 中的幂，证明了费马得出的一个基本结果，并阐述了单位群 $\mathbb{F}_q^*$ 的一个重要性质。

我们从一个简单的例子开始。表1.9列出了 $1,2,3,\ldots,6$ 对素数 $7$ 取模的幂。

![image-20251002191554461](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002191554491.png)

表1.9中可以看到不少有趣的模式，其中特别值得注意的是，最右侧一列全是 $1$ 。我们可以这样重新表述这一观察结果：
$$
a^6\equiv1({\mathrm{mod}}7)\quad\text{for every }a=1,2,3,\ldots,6.
$$
当然，这并非对所有的 $a$ 值都成立，因为如果 $a$ 是 $7$ 的倍数，那么它的所有幂次也都是 $7$ 的倍数，在这种情况下，$a^{n}\equiv0({\mathrm{mod}}7).$。另一方面，如果 $a$ 不能被 $7$ 整除，那么 $a$ 模 $7$ 的结果就等同于 $1,2,3,\ldots,6$ 中的某一个值。因此
$$
a^6\equiv\begin{cases}1&({\mathrm{mod}}7)&\mathrm{if}\ 7\nmid a,\\0&\mathrm{(mod}7)&\mathrm{if}\ 7\mid a.&\end{cases}
$$
**Theorem 1.24.** (费马小定理). 设 $p$ 是一个质数，且设 $a$ 是任意整数。那么
$$
a^{p-1}\equiv\begin{cases}1&({\mathrm{mod}}p)\quad if\ p\nmid a,\\0&({\mathrm{mod}}p)\quad if\ p\mid a.&\end{cases}
$$
Proof. 费马小定理有许多证明方法。如果你学过群论，最快的证明是观察到 $\mathbb{F}_q$ 中的非零元素构成一个阶为 $p-1$ 的群 $\mathbb{F}_q^*$，因此根据拉格朗日定理，$\mathbb{F}_q^*$ 中的每个元素的阶都能整除 $p−1$ 。对于那些还没有修过群论课程的人，我们提供一个直接证明。

如果 $p\mid a$，那么显然 $a$ 的任何次幂都能被 $p$ 整除。因此，我们只需要考虑 $p\nmid a$ 的情况。现在我们来看这一系列数字。
$$
a,\quad2a,\quad3a,\quad\ldots,\quad(p-1)a\quad\text{reduced modulo}\ p.\tag{1.8}
$$
这个列表中有 $p−1$ 个数，我们断言它们都是不同的。要弄明白为什么，任取其中两个数，比如 $\text{ja mod p}$ 和 $\text{ka mod p}$，并假设它们是相同的。这意味着
$$
ja\equiv ka({\mathrm{mod}}p),\quad\text{and hence that}\quad(j-k)a\equiv0({\mathrm{mod}}p).
$$
因此，$p$ 整除乘积 $(j−k)a$ 。命题1.19告诉我们，要么 $p$ 整除 $j−k$ ，要么 $p$ 整除 $a$ 。然而，我们已经假设 $p$ 不整除 $a$，所以我们可以得出结论： $p$ 整除 $j−k$ 。但 $j$ 和 $ k$ 都在 $1$ 到 $p−1$ 之间，因此它们的差 $j−k$ 在 $−(p−2) $到 $p−2$ 之间。在 $−(p−2) $ 到 $p−2$ 之间，只有一个数能被 $p$ 整除，这个数就是 $0$ ！这证明了 $j−k=0$ ，也就是说 $ja=ka$ 。因此，我们已经证明了列表（1.8）中的$p−1 $ 个数都是不同的。它们也都是非零的，因为 $1,2,3,\ldots,p-1$ 和 $a$ 都不能被 $p$ 整除。

概括来说，我们已经证明了数列（1.8）由 $p−1$ 个介于 $1$ 到 $ p−1$ 之间的不同数字组成。但介于 $1$ 到 $p−1$ 之间的不同数字只有 $p−1$ 个，因此数列（1.8）必定只是数字 $1,2,3,\ldots,p-1$ 以某种打乱的顺序排列而成的数列。



**Proposition 1.29.** 设 $p$ 为一个素数，$a$ 为一个不能被 $p$ 整除的整数。假设 $a^{n}\equiv1({\mathrm{mod}}p)$，那么 $a$ 模 $p$ 的阶能整除 $n$ 。特别地，$a$ 的阶能整除 $p-1$。

**Theorem 1.30** （原根定理）。设 $p$ 是一个素数。那么存在一个元素 $g\in\mathbb{F}_{p}^{*}$，其幂能生成 $\mathbb{F}_{p}^{*}$ 中的每一个元素，即
$$
\mathbb{F}_p^*=\{1,g,g^2,g^3,\ldots,g^{p-2}\}.
$$
**具有这种性质的元素被称为 $\mathbb{F}_{p}$ 的原根或 $\mathbb{F}_{p}^{*}$ 的生成元** 。它们是 $\mathbb{F}_{p}^{*}$ 中阶为 $p-1$ 的元素。

Example 1.31. 域 $\mathbb{F}_{11}$ 具有 $2$ 作为原根，因为在 $\mathbb{F}_{11}$ 中，
$$
2^{0}=1，2^{1}=2，2^{2}=4，2^{3}=8，
2^{4}=5，\\ 2^{5}=10， 2^{6}=9，2^{7}=7，2^{8}=3，2^{9}=6。
$$
因此，$\mathbb{F}_{11}$ 的所有 $10$ 个非零元素都被生成为 $2$ 的幂。另一方面，$ 2$ 不是 $\mathbb{F}_{17}$ 的原根，因为在 $\mathbb{F}_{17}$ 中，
$$
2^{0}=1，2^{1}=2，2^{2}=4，2^{3}=8，
2^{4}=16，\\ 2^{5}=15， 2^{6}=13，2^{7}=9，2^{8}=1
$$
所以在得到模 $17 $ 的所有 $16$ 个非零值之前，我们就回到了 $1$ 。不过，事实证明 $3$ 是 $17$ 的一个原根，因为在 $\mathbb{F}_{17}$ 中，
$$
3^{0}=1，3^{1}=3，3^{2}=9，3^{3}=10，
3^{4}=13， 3^{5}=5， \\ 3^{6}=15，3^{7}=11，3^{8}=16，3^{9}=14。 
3^{10}=8，3^{11}=7，\\ 3^{12}=4，3^{13}=12。3^{14}=2，3^{15}=6
$$


Remark 1.32. 如果 $p$ 很大，那么有限域 $\mathbb{F}_{p}$ 有相当多的原根。精确的公式表明，$\mathbb{F}_{p}$ 恰好有 $\phi(p-1)$ 个原根，其中 $\phi$ 是欧拉函数（见第22页）。例如，你可以验证以下是$ \mathbb{F}_{29}$ 的所有原根的完整列表：
$$
\{2,3,8,10,11,14,15,18,19,21,26,27\}.
$$
这与 $\phi(28)=12$ 的值一致。更一般地说，如果 $k$ 能整除 $p−1$ ，那么在 $\mathbb{F}_p^*$ 中恰好有 $\phi{(k)}$ 个元素的阶为 $k$。
