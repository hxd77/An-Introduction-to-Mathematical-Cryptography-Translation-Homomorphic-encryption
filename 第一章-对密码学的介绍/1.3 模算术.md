## 1.3 模算术

**Definition.**

我们写
$$
\mathbb{Z}/m\mathbb{Z}=\{0,1,2,\ldots,m-1\}
$$
并称$\mathbb{Z}/m\mathbb{Z}$为模$m$的整数环。我们对$\mathbb{Z}/m\mathbb{Z}$中的元素进行加法和乘法运算时，**先将它们作为整数进行加或乘，然后将结果除以$m$并取余数，以得到$\mathbb{Z}/m\mathbb{Z}$中的一个元素。**

图1.4通过给出完整的模5加法表和乘法表，对环$\mathbb{Z}/5\mathbb{Z}$进行了说明。

![image-20250930165601968](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20250930165601998.png)

Remark 1.16. 如果你学过环论，就会知道$\mathbb{Z}/m\mathbb{Z}$是 $\mathbb{Z}$ 对主理想 $m\mathbb{Z}$ 的商环，而数字$0,1,\ldots,m-1$实际上是构成$\mathbb{Z}/m\mathbb{Z}$元素的同余类的陪集代表元。关于同余类和一般商环的讨论，请参见2.10.2节。

**Definition.** Proposition 1.13（b）告诉我们，$a$存在模$m$的逆元当且仅当 $gcd（a，m）=1$。存在逆元的数被称为 $units$。我们用如下来表示所有$units$组成的集合。
$$
\begin{aligned}(\mathbb{Z}/m\mathbb{Z})^{*}&=\{a\in\mathbb{Z}/m\mathbb{Z}:\gcd(a,m)=1\}\\&=\{a\in\mathbb{Z}/m\mathbb{Z}:a\text{ has an inverse modulo }m\}.\end{aligned}
$$
集合$\mathbb{Z}/m\mathbb{Z}^{*}$被称为模$m$的 $units$ 群。

注意，如果$a_1$和$a_2$是模$m$的$units$，那么$a_1a_2$也是（你明白为什么会这样吗？）。所以，当我们将两个单位相乘时，得到的结果始终是一个$units$。而另一方面，当我们将两个单位相加时，得到的结果往往不是一个$units$。



Example 1.17. 模24的 $ units$ 群是
$$
(\mathbb{Z}/24\mathbb{Z})^*=\{1,5,7,11,13,17,19,23\}.
$$
同样地，模7的 $units$ 群是
$$
(\mathbb{Z}/7\mathbb{Z})^*=\{1,2,3,4,5,6\},
$$
**因为1到6之间的每个数都与7互质**。$\mathbb{Z}/24\mathbb{Z}$ 和 $\mathbb{Z}/7\mathbb{Z}$的乘法表如图1.5所示。

![image-20250930222255499](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20250930222255531.png)

**Definition.** 欧拉$\phi$函数（有时也称为欧拉 Totient 函数）是由以下规则定义的函数$\phi(m)$
$$
\phi(m)=\#\left(\mathbb{Z}/m\mathbb{Z}\right)^*=\#\{0\leq a<m:\gcd(a,m)=1\}.
$$
例如，我们从例1.17中可以看到 $\phi{(24)}=8$ 且 $\phi{(7)}=6$ (与$m$互素的个数)

### 1.3.1 模运算与移位密码

回想一下，在1.1节中研究的凯撒（或移位）密码的工作原理是将字母表中的每个字母都向后移动固定数量的字母。我们可以通过像表1.7中那样给每个字母分配一个数字，从数学角度来描述移位密码。

![image-20251002163355546](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002163402610.png)

那么，一个移位为 $k$ 的移位密码会将对应数字 $p$ 的明文字母转换为对应数字 $p+k$ 模 $26$ 的密文字母。注意，在这种情况下，模26运算的使用简化了移位密码的描述。**移位量既作为加密密钥，也作为解密密钥**。加密由以下公式给出
$$
\text{(Ciphertext Letter)}\equiv\text{(Plaintext Letter)}+\text{(Secret Key)}({\mathrm{mod}}26),
$$
而解密则通过向相反方向移位来实现，
$$
\text{(Plaintext Letter)}\equiv\text{(Ciphertext Letter)}-\text{(Secret Key)}({\mathrm{mod}}26).
$$
更简洁地说，如果我们令
$$
p = \text{Plaintext Letter}, \qquad c = \text{Ciphertext Letter}, \qquad k = \text{Secret Key}
$$
那么
$$
\underbrace{c \equiv p + k \pmod{26}}_{\text{Encryption}} \qquad \text{and} \qquad \underbrace{p \equiv c - k \pmod{26}}_{\text{Decryption}}.
$$


### 1.3.2 快速幂算法

在我们将要研究的一些密码系统中，例如RSA和Diffie-Hellman密码系统，爱丽丝和鲍勃需要计算一个数 $g$ 对另一个数 $N$ 取模的大幂次，其中$N$可能有数百位。计算$g^A$的朴素方法是通过反复乘以$g$。因此
$$
g_1\equiv g({\mathrm{mod}}N),\quad g_2\equiv g\cdot g_1({\mathrm{mod}}N),\quad g_3\equiv g\cdot g_2({\mathrm{mod}}N),\\
\quad g_4\equiv g\cdot g_3({\mathrm{mod}}N),\quad g_5\equiv g\cdot g_4({\mathrm{mod}}N),\ldots
$$
显然，$g_{A}\equiv g^{A}({\mathrm{mod}} N),$，但如果$A$很大，这种算法就完全不实用了。例如，若$A\approx2^{1000}$，那么这种朴素算法所需的时间会比宇宙的估计年龄还要长！显然，要让它有用，我们需要找到一种更好的方法来计算$g^{A}({\mathrm{mod}}N).$

其思路是利用指数$A$的二进制展开式，将$g^A$的计算转化为一系列的平方运算和乘法运算。我们先通过一个例子来阐明这个思路，之后再对该方法进行正式描述。

Example 1.18. 假设我们想计算$3^{218}({\mathrm{mod}}\ 1000)$。第一步是将218写成2的幂的和，
$$
\begin{array}{c}218=2+2^3+2^4+2^6+2^7.\end{array}
$$
然后$3^{218}$变成：
$$
3^{218}=3^{2+2^3+2^4+2^6+2^7}=3^2\cdot3^{2^3}\cdot3^{2^4}\cdot3^{2^6}\cdot3^{2^7}.\tag{1.3}
$$
请注意，计算这一系列值相对容易。
$$
\begin{array}{ccccc}3,&3^2,&3^{2^2},&3^{2^3},&3^{2^4},\ldots,\end{array}
$$
因为**序列中的每个数字都是前一个数字的平方**（跟3没关系，主要是2的次方）。此外，由于我们只需要这些值对1000取模的结果，所以我们永远不需要存储超过三位数字。表1.8列出了3的幂对1000取模的结果，一直到3的27次幂。尽管3的27次幂这个数的指数相当大，但创建表1.8只需要7次乘法，因为表中每个后续的条目都等于前一个条目的平方。

![image-20251002164752550](https://raw.githubusercontent.com/hxd77/BlogImage/master/TyporaImage/20251002164752574.png)

我们使用（1.3）来确定需要表1.8中的哪些幂来计算$3^{218}$。因此
$$
\begin{aligned}3^{218}&=3^{2}\cdot3^{2^{3}}\cdot3^{2^{4}}\cdot3^{2^{6}}\cdot3^{2^{7}}\\&\equiv9\cdot561\cdot721\cdot281\cdot961({\mathrm{mod}}1000)\\&\equiv489({\mathrm{mod}}1000).\end{aligned}
$$
我们注意到，在计算乘积 $9·561·721·281·961$ 时，我们可以在每次乘法后对1000取模，这样就永远不必处理非常大的数。我们还观察到，计算 $3^{218}({\mathrm{mod}}\ 1000)$ 只需要11次乘法，这比朴素方法节省了大量运算。而且对于更大的指数，我们节省的运算量会更多。

例1.18中使用的通用方法有多种名称，包括快速幂算法和平方-乘算法。我们现在更正式地描述该算法。
$$
\boxed{\quad\text{The Fast Powering Algorithm}\quad}
$$
**Step 1.** 计算 $A$ 的二进制展开式，如下所示：
$$
A = A_{0} + A_{1} \cdot 2 + A_{2} \cdot 2^{2} + A_{3} \cdot 2^{3} + \cdots + A_{r} \cdot 2^{r} \quad \text { with } A_{0}, \ldots, A_{r} \in\{0,1\},
$$
其中我们假设 $A_{r}=1$.

**Step 2.**





## 1.4 质数、唯一分解以及有限域

在1.3节中，我们学习了模算术，并了解到对整数进行模 $m$ 的加、减和乘法运算都是有意义的。然而，除法可能会存在问题，因为只有当$\gcd（a，m）=1$时，我们才能在$\mathbb{Z}/m\mathbb{Z}$中除以$a$。但需要注意的是，如果整数$m$是一个质数，那么我们就可以除以$\mathbb{Z}/m\mathbb{Z}$中的每一个非零元素。在回到$p$为质数的环$\mathbb{Z}/p\mathbb{Z}$之前，我们先简要讨论一下质数。

**Definition.** 如果一个整数 $p$ 满足 $p≥2$ ，且能整除$p$的正整数只有 $1$ 和 $p$ 本身，那么 $p$ 就被称为质数。

例如，前$10$个质数是$2、3、5、7、11、13、17、19、23、29$，而第$10$万个质数是$1299709$，第$100$万个质数是$15485863$。质数有无限多个，这一事实在古希腊就已为人所知，并作为定理出现在欧几里得的《几何原本》中（参见练习1.28）。

一个质数 $p$ 的定义取决于能整除 $p$ 的数。因此，下面这个描述能被 $p$ 整除的数的一个有用性质的命题并不明显，需要仔细证明。注意，这个命题对于合数来说是不成立的。例如，$6$ 能整除 $3·10$，但 $6$ 既不能整除 $3$，也不能整除 $10$ 。

**Proposition 1.19.** 设 $p$ 是一个质数，并且假设 $p$ 能整除两个整数 $a$ 和 $b$ 的乘积 $ab$。那么 $p$ 至少能整除 $a$ 和 $b$ 中的一个。更一般地说，如果 $p$ 能整除整数的一个乘积，比如
$$
p\mid a_1a_2\cdots a_n,
$$
那么 $p$ 至少能整除其中一个单独的 $a_i$。



Proof. 令$g=\gcd(a,p)$。那么$g$能整除$p$，因此 $g$ 要么等于 $1$ ，要么等于 $p$。如果 $g = p$，那么 $p$ 能整除 $a$（因为 $g$ 能整除 $a$），这样我们就完成了证明。否则，$g = 1$，且定理1.11告诉我们，我们可以找到整数 $u$ 和 $v$，使得 $au + pv = 1$ 。我们将等式两边同时乘以 $b$，得到
$$
\begin{array}{c}abu+pbv=b.\end{array}\tag{1.5}
$$
根据假设，$p$ 整除乘积 $ab$，并且显然 $p$ 整除 $pbv$，因此 $p$ 整除（1.5）式左侧的两项。由此可知，$p$ 整除右侧，这表明 $p$ 整除 $b$，从而完成了命题1.19的证明。

为了证明更具一般性的结论，我们将这个乘积写成 $a_1(a_2···a_n)$，并对 $a = a₁$ 和 $b = a_2···a_n$ 应用第一个结论。如果 $p$ 能整除$a_1$，那么我们就完成了证明。否则，$p$ 能整除 $a_2···a_n$，于是将其写成$a_2(a₃···a_n)$ ，第一个结论告诉我们，要么 $p$ 能整除 $a_2$ ，要么 $p$ 能整除 $a_3···a_n$ 。按照这种方式继续下去，我们最终必定能找到某个能被 $p$ 整除的 $a_i$。

作为命题1.19的一个应用，我们证明每个正整数都有一个本质上唯一的素数乘积分解式。



**Theorem 1.20** （算术基本定理）设 $a$ 是大于等于 $2$ 的整数，那么 $a$ 可以分解为素数的乘积。
$$
a=p_1^{e_1}\cdot p_2^{e_2}\cdot p_3^{e_3}\cdot\cdot\cdot p_r^{e_r}.
$$
此外，除了重新排列质数的顺序外，**这种分解为质数幂的方式是唯一的。**



Proof. 不难证明，每个$a\ge 2$ 都可以分解为素数的乘积。人们很容易认为这种分解的唯一性也是显而易见的。然而，事实并非如此；唯一分解性是整数的一个略显微妙的性质。我们将利用命题1.19的一般形式来证明这一点（关于唯一分解性不成立的情况示例，参见文献[137，第7章]中描述的E区）。

假设 $a$ 有两种分解方式，可分解为质数的乘积，
$$
a=p_1p_2\cdots p_s=q_1q_2\cdots q_t,\tag{1.6}
$$
其中 $p_i$ 和 $q_j$均为质数，它们不一定互不相同，且 $s$ 也不一定等于 $t$。由于 $p_1$ 能整除 $a$，我们可知 $p_1$ 能整除乘积 $q_1q_2q_3\cdots q_t$。因此，根据命题1.19的一般形式，我们发现 $p_1$ 能整除其中一个$q_i$。如果有必要，重新排列这些 $q_i$ 的顺序，我们可以假设 $p_1$ 整除 $q_1$。但 $p_1$ 和 $q_1$都是质数，所以我们必定有 $p_1 = q_1$。这使我们能够从（1.6）式的两边消去它们，从而得到
$$
p_2p_3\cdots p_s=q_2q_3\cdots q_t.
$$
重复这个过程 $s$ 次，我们最终会得到一个如下形式的方程
$$
\begin{array}{c}1=q_{t-s}q_{t-s+1}\cdots q_t.\end{array}
$$
由此立即可以得出 $t = s$，并且 $a$ 的原始因式分解除了因子的顺序可以重新排列外是完全相同的。（有关算术基本定理的更详细证明，请参见任何基础数论教科书，例如[35, 52, 59, 100, 111, 137]。）

>每个 $q_j$ 都是素数，所以都大于 $1$。
>
>如果乘积等于 $1$，说明**这个乘积里面没有素数**。
>
>如果 $s<t$，右边至少有一个素数，乘积 $≥ 2$，不可能 $=1$。
>
>如果 $s>t$，符号就不合逻辑（因为因子个数不能是负数）。
>
>唯一可能就是 $s=t$，此时乘积是空积（没有素数相乘），约定值就是 $1$。



**Definition.** 算术基本定理（定理1.20）表明，在将正整数 $a$ 分解为素数的过程中，每个素数 $p$ 都以特定的幂次出现。我们用 $ord_p(a)$ 来表示这个幂次，并称之为 $p$ 在 $a$ 中的阶（或指数）。（为方便起见，对于所有素数，我们规定 $ord_p(1)=0$。）

例如，$1728$的因式分解是$1728 = 2^6\cdot 3^3$，所以

